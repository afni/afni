#!/bin/tcsh -f

PARSE: 
	echo "Parsing ..."
	set Narg = $#
   set base = ''
   set input = ''
   set cropt = '-coarserot'
   set blr_input = 8
   set blr_base = 8
   set pad_base = 10
   set rmode = 'default'
   set xform_type = 'affine_general'
   set suf = 'final'
   set KeepTmp = 0
   set TS = "_"
   set dxyz_list = ( 1 1 1 )
   set cnt = 1
   if ("$1" == '') then
      goto HELP
   endif
   while ($cnt <= $Narg)
		set donext = 1;
      if ("$argv[$cnt]" == "-help" || "$argv[$cnt]" == "-h") then
         goto HELP
      endif
      if ($donext && "$argv[$cnt]" == "-xform") then
         set pLoc = $cnt      
         if ($pLoc == $Narg) then
            echo "Need string after -xform"
            goto END
         else
            @ cnt ++
            set xform_type = "$argv[$cnt]"
            if ("$xform_type" != "affine_general" && "$xform_type" != "shift_rotate_scale" && "$xform_type" != "auto" && "$xform_type" != "shift_rotate") then
               echo "-xform option $xform_type not allowed."
               goto END
            endif
            if ("$xform_type" == "shift_rotate") then
               echo ""
               echo "Warning: ********************************"
               echo "-xform option does not allow for scaling!"
               echo "Proceeding with your wishes anyway ..."
               echo ""
            endif
            set donext = 0   
         endif   
      endif
      if ($donext && "$argv[$cnt]" == "-rmode") then
         set pLoc = $cnt		
		   if ($pLoc == $Narg) then
				echo "Need string after -rmode"
            goto END
			else
            @ cnt ++
            set rmode = "$argv[$cnt]"
            set donext = 0	
         endif	
      endif
      if ($donext && "$argv[$cnt]" == "-dxyz") then
         set pLoc = $cnt		
		   if ($pLoc == $Narg) then
				echo "Need voxel size after -dxyz"
            goto END
			else
            @ cnt ++
            set dxyz_list[1] = "$argv[$cnt]"
            set dxyz_list[2] = "$argv[$cnt]"
            set dxyz_list[3] = "$argv[$cnt]"
            set donext = 0	
         endif	
      endif
      if ($donext && "$argv[$cnt]" == "-suffix") then
         set pLoc = $cnt		
		   if ($pLoc == $Narg) then
				echo "Need a string after -suffix"
            goto END
			else
            @ cnt ++
            set suf = "$argv[$cnt]"
            set donext = 0	
         endif	
      endif
      if ($donext && "$argv[$cnt]" == "-base") then
         set pLoc = $cnt		
		   if ($pLoc == $Narg) then
				echo "Need template volume after -base"
            goto END
			else
            @ cnt ++
            set base = "$argv[$cnt]"
            set b_name = `@parse_afni_name $base`
            set cb_name = ($b_name)
            set donext = 0	
         endif	
      endif
      if ($donext && "$argv[$cnt]" == "-pad_base") then
         set pLoc = $cnt		
		   if ($pLoc == $Narg) then
				echo "Need value after -pad_base"
            goto END
			else
            @ cnt ++
            set pad_base = "$argv[$cnt]"
            if ($pad_base > 100 || $pad_base < 0) then
               echo "Error: -base_pad should be between 0 and 100"
               echo "I have $pad_base"
               goto END
            endif
            set donext = 0	
         endif	
      endif
      if ($donext && "$argv[$cnt]" == "-input") then
         set pLoc = $cnt		
		   if ($pLoc == $Narg) then
				echo "Need  volume after -input"
            goto END
			else
            @ cnt ++
            set input = "$argv[$cnt]"
            set i_name = `@parse_afni_name $input`
            set ci_name = ($i_name)
            set donext = 0	
         endif	
      endif
      if ($donext && "$argv[$cnt]" == "-blr_input") then
         set pLoc = $cnt		
		   if ($pLoc == $Narg) then
				echo "Need fwhm blur after -blr_input"
            goto END
			else
            @ cnt ++
            set blr_input = "$argv[$cnt]"
            if ($blr_input > 30 || $blr_input < 0) then
               echo "Error: -blr_input should be between 0 and 30"
               echo "I have $blr_input"
               goto END
            endif
            set donext = 0	
         endif	
      endif
      if ($donext && "$argv[$cnt]" == "-blr_base") then
         set pLoc = $cnt		
		   if ($pLoc == $Narg) then
				echo "Need fwhm blur after -blr_base"
            goto END
			else
            @ cnt ++
            set blr_base = "$argv[$cnt]"
            if ($blr_base > 30 || $blr_base < 0) then
               echo "Error: -blr_base should be between 0 and 30"
               echo "I have $blr_base"
               goto END
            endif
            set donext = 0	
         endif	
      endif
      if ($donext && "$argv[$cnt]" == "-blr_all") then
         set pLoc = $cnt		
		   if ($pLoc == $Narg) then
				echo "Need fwhm blur after -blr_all"
            goto END
			else
            @ cnt ++
            set blr_base = "$argv[$cnt]"
            set blr_input = "$argv[$cnt]"
            if ($blr_base > 30 || $blr_base < 0 ) then
               echo "Error: -blr_all should be between 0 and 30"
               echo "I have $blr_base"
               goto END
            endif
            set donext = 0	
         endif	
      endif
      if ($donext && "$argv[$cnt]" == "-keep_tmp") then
         set KeepTmp = 1;		
         set donext = 0		
      endif
      
      if ($donext && "$argv[$cnt]" == "-ncr") then
         set cropt = '';		
         set donext = 0		
      endif
      
      if ($donext && "$argv[$cnt]" == "-verb") then
         set verb = 1;		
         set donext = 0		
      endif
      if ($donext == 1) then
         echo "Error: Option or parameter '$argv[$cnt]' not understood"
         goto END
      endif
		@ cnt ++
	end
   if ("$base" == "" || "$input" == "") then
      echo "Error: Need both -base and -input parameters"
      goto END
   endif
      
   #set default rmode
   if ("$rmode" == "default") then
         set rmode = "quintic"
   endif


CLEANUP_BEGINNING:
rm -f *_${TS}_*.HEAD *_${TS}_*.BRIK >& /dev/null 

BUDINESS:

#blur data
if ($blr_input) then
   3dmerge -1blur_fwhm $blr_input -prefix $ci_name[1]/$ci_name[2]_${TS}_blr $ci_name[1]/$ci_name[2]$ci_name[3]
   set ci_name[2] = $ci_name[2]_${TS}_blr 
endif

if ($blr_base) then
   3dmerge -1blur_fwhm $blr_base -prefix $cb_name[1]/$cb_name[2]_${TS}_blr $cb_name[1]/$cb_name[2]$cb_name[3]
   set cb_name[2] = $cb_name[2]_${TS}_blr 
endif

#pad the base by some mm
if ($pad_base) then
   3dZeropad   -I $pad_base -S $pad_base -A $pad_base -P $pad_base -L $pad_base -R $pad_base -mm \
               -prefix $cb_name[1]/$cb_name[2]_${TS}_pad $cb_name[1]/$cb_name[2]$cb_name[3]
   set cb_name[2] = $cb_name[2]_${TS}_pad
endif

#resample the input to look like the base
3dresample  -master $cb_name[1]/$cb_name[2]$cb_name[3] -rmode Cu \
            -prefix $ci_name[1]/$ci_name[2]_${TS}_resamp \
            -inset $ci_name[1]/$ci_name[2]$ci_name[3]
set ci_name[2] = $ci_name[2]_${TS}_resamp
            
#do the warping deed   

3dWarpDrive    -twopass $cropt -${xform_type} -cubic  \
               -final ${rmode} -base $cb_name[1]/$cb_name[2]$cb_name[3] \
               -prefix $ci_name[1]/$ci_name[2]_${TS}_wd -input $ci_name[1]/$ci_name[2]$ci_name[3]
set ci_name[2] = $ci_name[2]_${TS}_wd

#because of resampling and other tricks, best to warp the pure input by the final xform
3dWarp -matparent $ci_name[1]/$ci_name[2]$ci_name[3] -$rmode -prefix $i_name[1]/$i_name[2]${suf} $i_name[1]/$i_name[2]$i_name[3] 

CLEANUP_END:
if ($KeepTmp == 0) then
   rm -f *_${TS}_*.HEAD *_${TS}_*.BRIK >& /dev/null 
endif

goto END

HELP:
if ("$1" == '' || "$1" == "-help" || "$1" == "-h") then
   echo "Beginnings of a script to improve alignment of EPI to anatomical data"
   echo ""
   echo "   `basename $0` <-input epi> <-base anat>"
   echo "                 [-blr_input FWHM_input] [-blr_base FWHM_base] [-blr_all FWHM]"
   echo "                 [-suffix SUF] [-keep_tmp] "
   echo ""
      echo "      -keep_tmp      :  Keep temporary files."
      echo "      -xform  XFORM  : Transform to use for warping:"
      echo "                       Choose from affine_general or shift_rotate_scale"
      echo "                       Default is affine_general but the script will"
      echo "                       automatically try to use shift_rotate_scale "
      echo "                       if the alignment does not converge."
   echo ""
   goto END
endif


END:
