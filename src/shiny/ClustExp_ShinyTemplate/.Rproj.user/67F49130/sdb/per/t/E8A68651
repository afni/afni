{
    "collab_server" : "",
    "contents" : "#####################################\n## 09/2017 Justin Rajendra\n## Cluster Explorer\n## plot and stat functions\n\nlibrary(psych)\nlibrary(RColorBrewer)\nlibrary(afex)\nlibrary(plotly)\n################################################\n## helper functions\n\n\n################\n## make a vector of variable depending on the split\n## takes some categorical variables and how to combine them\nvarCombine <- function(bsVars.in,wsVars.in,bs_ws.split){\n  model.final <- NA\n  if(!is.null(bs_ws.split)){\n    if(bs_ws.split == \"Within\"){\n      if(!is.null(wsVars.in)){\n        model.final <- wsVars.in\n      } else { print(\"variables names are NULL\") ; model.final <- NA }\n    } else if(bs_ws.split == \"Between\"){\n      if(!is.null(bsVars.in)){\n        model.final <- bsVars.in\n      } else { print(\"variables names are NULL\") ; model.final <- NA }\n    } else if(bs_ws.split == \"Both\"){\n      if(!is.null(bsVars.in) & !is.null(wsVars.in)){\n        model.final <- c(bsVars.in,wsVars.in)\n      } else { print(\"variables names are NULL\") ; model.final <- NA }\n    }\n  } else {\n    if(!all(is.na(bsVars.in)) & bsVars.in[1] != \"None\"){\n      model.final <- bsVars.in\n    } else if(!is.na(wsVars.in)){\n      model.final <- wsVars.in\n    }\n  }\n  return(model.final)\n}   ## end varCombine\n\n################\n## return data frame of categorical interaction models\n## takes the data, some categorical variables and how to combine them\nInteractionFrame <- function(data.in,bsVars.in,wsVars.in,bs_ws.split){\n\n  ## check inputs\n  if(!is.data.frame(data.in)){\n    print(\"Input is not a data frame\")\n    return(NA)\n  }\n  if(is.null(bsVars.in) & is.null(wsVars.in)){\n    print(\"Need something to make a model\")\n    return(NA)\n  }\n\n  ## get all of the model vars\n  model.final <- varCombine(bsVars.in,wsVars.in,bs_ws.split)\n\n  ## combine the groups if necessary\n  if(length(model.final) > 1){\n    data.in$Groups <- apply(data.in[,model.final],1,paste,collapse=\".\")\n    data.in$Groups <- factor(data.in$Groups)\n  } else {\n    data.in$Groups <- data.in[[model.final]]\n  }\n  return(data.in)\n}   ## end InteractionFrame\n\n################\n## return data frame with summary stats for by level\n## takes a data frame, the continuous variable and a categorical variable\nInteractionCalc <- function(data.in,cont.var,fact.var){\n\n  ## stat by level\n  mean.df <- aggregate(data.in[[cont.var]],list(data.in[[fact.var]]),mean)\n  sd.df <- aggregate(data.in[[cont.var]],list(data.in[[fact.var]]),sd)\n  se.df <- aggregate(data.in[[cont.var]],list(data.in[[fact.var]]),std.err.mean)\n  n.df <- aggregate(data.in[[cont.var]],list(data.in[[fact.var]]),length)\n\n  ## combine, rename, and return\n  out.df <- cbind(mean.df,sd.df$x,se.df$x,n.df$x)\n  names(out.df) <- c(fact.var,\"Mean\",\"SD\",\"SE\",\"n\")\n  return(out.df)\n}  ## end InteractionCalc\n\n\n\n################################################\nstat_plot_fun <- function(plot.df,prefix,p_val,stat.info,clust.lab,\n                          bsVarsCat.sel,vox.vol,fixed.range,custom.range,\n                          qVars.sel,wsVars.sel,one.plot,col.pal,marker.size,\n                          marker.opacity,box.points,line.width,box.mean,\n                          bs_ws.split,qVars.center.sel,box.scatter,\n                          jit,error.bars){\n\n  ## return empty on waiting\n  if(nrow(plot.df) == 0){ return(plotly_empty()) }\n\n  ## change box.mean to logical if needed\n  if(!is.null(box.mean)){\n    if(box.mean != 'sd'){ box.mean <- as.logical(box.mean) }\n  }\n\n  ## y axis zoom\n  if(fixed.range){\n    y.axis <- list(title='',range=custom.range)\n  } else {\n    y.axis <- list(title='')\n  }\n\n  ## make color list for everything but ttest\n  if(stat.info != \"Ttest\"){\n    if(is.null(col.pal)){\n      col.list <- brewer.pal(200,\"Dark2\")\n    } else {\n      col.list <- brewer.pal(200,col.pal)\n    }\n  }\n\n  ## modify plotly window\n  plotly.layout <- list(\"toImage\",\"hoverCompareCartesian\",\n                        \"hoverClosestCartesian\", \"toggleSpikelines\")\n\n  ################################################\n  if(stat.info == \"Ttest\"){\n\n    ## make color list\n    if(is.null(col.pal)){\n      col.list <- c('red','blue')\n    } else if(col.pal == 'RedBlue'){\n      col.list <- c('red','blue')\n    } else {\n      col.list <- brewer.pal(3,col.pal)\n    }\n\n    ## plotly\n    plot.ly <- plot_ly(plot.df,x=~Group,y=~value,color=~Group,type='box',\n                       colors=col.list,showlegend=FALSE,\n                       boxpoints=box.points,boxmean=box.mean)\n    layout(plot.ly,title=paste0(clust.lab,\" (\",vox.vol,\" voxels)\"),\n           yaxis=y.axis,margin=list(t=80)) %>%\n      config(displaylogo=FALSE,modeBarButtonsToRemove=plotly.layout)\n\n    ################################################\n    ## box plots\n  } else if(stat.info == \"3dMVM\" & box.scatter == \"Box\"){\n\n    ## return empty if nothing here\n    if(is.null(bsVarsCat.sel) & bs_ws.split == \"Between\"){\n      return(plotly_error(\"Must have at least one categorical variable!\"))\n    }\n    if(is.null(wsVars.sel) & bs_ws.split == \"Within\"){\n      return(plotly_error(\"Must have at least one categorical variable!\"))\n    }\n    if(is.null(bsVarsCat.sel) & is.null(wsVars.sel)){\n      return(plotly_error(\"Must have at least one categorical variable!\"))\n    }\n    if(!is.null(bsVarsCat.sel) & is.null(wsVars.sel)){\n      if(bsVarsCat.sel == \"None\"){\n        return(plotly_error(\"Must have at least one categorical variable!\"))\n      }\n    }\n\n    ## get the combinations of categorical variables\n    plot.df <- InteractionFrame(plot.df,bsVarsCat.sel,wsVars.sel,bs_ws.split)\n\n    ## plot\n    plot.ly <- plot_ly(plot.df,x=~Groups,y=~value,type=\"box\",color=~Groups,\n                       colors=col.list,boxpoints=box.points, boxmean=box.mean)\n    layout(plot.ly,title=paste0(clust.lab,\" (\",vox.vol,\" voxels)\"),\n           yaxis=y.axis,margin=list(t=80)) %>%\n      config(displaylogo=FALSE,modeBarButtonsToRemove=plotly.layout)\n\n\n    ################################################\n    ## interaction plots\n  } else if(stat.info == \"3dMVM\" & box.scatter == \"Interaction\"){\n\n    ## return empty if nothing here\n    if(is.null(bsVarsCat.sel) & is.null(wsVars.sel)){\n      return(plotly_error(\"Must have at least one categorical variable!\"))\n    }\n    if(bsVarsCat.sel == \"None\" & is.null(wsVars.sel)){\n      return(plotly_error(\"Must have at least one categorical variable!\"))\n    }\n\n    ## get all of the model vars\n    model.final <- varCombine(bsVarsCat.sel,wsVars.sel,bs_ws.split)\n\n    ## no more than 2 categorical variables\n    if(length(model.final) != 2 ){\n      return(plotly_error(\"Need exactly 2 categorical variables!\"))\n    }\n\n    ## split by first variable and do the stats by the second\n    lvl.list <- split(plot.df,plot.df[[model.final[1]]])\n    stat.list <- lapply(lvl.list,\n                        function(x) InteractionCalc(x,\"value\",model.final[2]))\n\n    ## plot parameters\n    if(is.null(marker.size)){ marker.size <- 12 ; marker.opacity <- 0.8 }\n    x.lvl <- levels(plot.df[[model.final[2]]])\n    x.axis <- list(title=model.final[2],autotick=FALSE,tickmode='array',\n                   tickvals=c(1:length(x.lvl)),ticktext=x.lvl,\n                   zeroline=FALSE)\n    y.axis$zeroline <- FALSE\n    if(error.bars == 'no'){\n      error.list <- list(visible=FALSE)\n    } else if(error.bars == 'SD') {\n      error.list <- list(type=\"data\",array=~SD,thickness=line.width)\n    } else if(error.bars == 'SE') {\n      error.list <- list(type=\"data\",array=~SE,thickness=line.width)\n    }\n\n    ## plot\n    plot.ly <- plot_ly()\n    for(i in 1:length(stat.list)){\n\n      ## colors\n      marker.list <- list(size=marker.size,color=col.list[i],\n                          opacity=marker.opacity)\n      line.list <- list(color=col.list[i],width=line.width)\n\n      ## add jitter and plot\n      x.jit <- jitter(c(1:length(x.lvl)),jit)\n      plot.ly <- add_trace(plot.ly,data=stat.list[[i]],x=x.jit,y=~Mean,\n                           type='scatter',mode='markers+lines',\n                           name=names(stat.list)[i],text=~n,\n                           error_y=error.list,hoverinfo=\"y+text\",\n                           marker=marker.list,line=line.list)\n    }\n    layout(plot.ly,title=paste0(clust.lab,\" (\",vox.vol,\" voxels)\"),\n           yaxis=y.axis,xaxis=x.axis,margin=list(t=80)) %>%\n      config(displaylogo=FALSE,modeBarButtonsToRemove=plotly.layout)\n\n    ## end interaction\n    ################################################\n    ## has categorical and quantitative variables\n  } else if(stat.info == \"3dMVM\" & box.scatter == \"Scatter\"){\n\n    ## temp markers\n    if(is.null(marker.size)){ marker.size <- 8 ; marker.opacity <- 0.8 }\n\n    ## return empty if nothing here\n    if(bsVarsCat.sel == \"None\" & is.null(wsVars.sel)){ return(plotly_empty()) }\n\n    ## get the combinations of categorical variables\n    plot.df <- InteractionFrame(plot.df,bsVarsCat.sel,wsVars.sel,bs_ws.split)\n\n    ## levels for looping\n    n.lvl <- length(levels(plot.df$Groups))\n    names.lvl <- levels(plot.df$Groups)\n\n    ## check for qVars and center them to mean or specified\n    if(qVars.center.sel){\n      ## center by mean\n      if(is.na(SI.df$qVarCenters)){\n        center.str <- \"mean\"\n        for(i in 1:length(qVars)){\n          plot.df[,qVars[i]] <- scale(plot.df[[qVars[i]]],center=TRUE,\n                                      scale=FALSE)\n        }\n      } else {   ## center by value\n        center.str <- SI.df$qVarCenters\n        qVars.cent <- as.numeric(unlist(tstrsplit(SI.df$qVarCenters,',')))\n        for(i in 1:length(qVars)){\n          plot.df[,qVars[i]] <- scale(plot.df[[qVars[i]]],\n                                      center=qVars.cent[[i]],scale=FALSE)\n        }\n      }\n    }   ## end centering\n\n    ## one plot or subplots\n    if(!one.plot){   ## overlay all plots\n      plot.ly <- plot_ly()\n      ## loop through the levels of the selected variable\n      for(i in 1:n.lvl){\n\n        ## subset and make a new data frame for easy names\n        temp.df <- subset(plot.df,plot.df$Groups == names.lvl[i])\n        plot.temp <- data.frame(x=temp.df[[qVars.sel]],y=temp.df$value,\n                                Subj=temp.df$Subj)\n\n        ## do the fit with the custom function\n        fit.calc <- lmCalc(plot.temp,\"x\",\"y\")\n        plot.fit <- fit.calc$fit\n        rValue <- paste0('R = ',signif(fit.calc$R,digits=2))\n        pValue <- paste(\"p = \",signif(fit.calc$p,digits=2))\n        legend.text <- paste0(rValue,' (',pValue,')')\n\n        ## axis property lists\n        x.axis <- list(title=qVars.sel)\n        marker.list <- list(size=marker.size,color=col.list[i],\n                            opacity=marker.opacity)\n        line.list <- list(color=col.list[i],width=line.width)\n        ## plot\n        plot.ly <- add_trace(plot.ly,data=plot.temp,x=~x,y=~y,type='scatter',\n                             mode='markers',text=~Subj,name=names.lvl[i],\n                             marker=marker.list)\n        plot.ly <- add_trace(plot.ly,x=plot.temp$x,y=fitted(plot.fit),\n                             name=legend.text,line=line.list,\n                             type='scatter',mode='lines',inherit=FALSE)\n      }\n      layout(plot.ly,title=paste0(clust.lab,\" (\",vox.vol,\" voxels)\"),\n             yaxis=y.axis,xaxis=x.axis,margin=list(t=80)) %>%\n        config(displaylogo=FALSE,modeBarButtonsToRemove=plotly.layout)\n\n      ################################################\n    } else {   ## subplots\n      ## make a list to save all of the plots\n      plot.list <- list()\n\n      ## loop through the levels of the selected variable\n      for(i in 1:n.lvl){\n\n        ## subset and make a new data frame for easy names\n        temp.df <- subset(plot.df,plot.df$Groups == names.lvl[i])\n        plot.temp <- data.frame(x=temp.df[[qVars.sel]],y=temp.df$value,\n                                Subj=temp.df$Subj)\n\n        ## do the fit with the custom function\n        fit.calc <- lmCalc(plot.temp,\"x\",\"y\")\n        plot.fit <- fit.calc$fit\n        rValue <- paste0('R = ',signif(fit.calc$R,digits=2))\n        pValue <- paste(\"p = \",signif(fit.calc$p,digits=2))\n        legend.text <- paste0(rValue,' (',pValue,')')\n\n        ## axis property lists\n        x.axis <- list(title=qVars.sel)\n        marker.list <- list(size=marker.size,color=col.list[i],\n                            opacity=marker.opacity)\n        line.list <- list(color=col.list[i],width=line.width)\n\n        ## plot\n        plot.ly <- plot_ly(plot.temp,x=~x,y=~y,type='scatter',mode='markers',\n                           text=~Subj,name=names.lvl[i], marker=marker.list)\n        plot.ly <- add_trace(plot.ly,x=plot.temp$x,y=fitted(plot.fit),\n                             name=legend.text,line=line.list,\n                             type='scatter',mode='lines',inherit=FALSE)\n        plot.ly <- layout(plot.ly,yaxis=y.axis,xaxis=x.axis,margin=list(t=80),\n                          title=paste0(clust.lab,\" (\",vox.vol,\" voxels)\")) %>%\n          config(displaylogo=FALSE,modeBarButtonsToRemove=plotly.layout)\n\n        ## add to plot list\n        plot.list[[i]] <- plot.ly\n\n      }   ## end level loop\n      ## plot all in list with 2 per row\n      if(n.lvl == 1){ plot.rows <- 1 } else { plot.rows <- ceiling(n.lvl/2) }\n      subplot(plot.list,shareX=TRUE,shareY=TRUE,nrows=plot.rows)\n    }   ## end overplot ancova\n  }   ## end different plots\n}   ## end stat_plot_fun\n\n################################################\n## function for statistics summary\nstat_fun <- function(plot.df,prefix,p_val,stat.info,t.paired,clust.lab,\n                     bsVarsCat.sel,vox.vol,qVars.sel,wsVars.sel,orig.plot,\n                     bs_ws.split,box.scatter){\n\n  ## make sure there is something there there\n  if(nrow(plot.df) == 0){ return(\"please wait\") }\n\n  ## return ttest for paired or not (same format as the anova summary)\n  if(stat.info == \"Ttest\"){\n    if(t.paired){\n      return(summary(aov(value ~ Group + Error(Subj),plot.df)))\n    } else {\n      return(summary(aov(value ~ Group,plot.df)))\n    }\n  }\n\n  ## stat for whatever it was originally\n  if(orig.plot == \"orig\" & !is.na(wsVars.model)){\n    model.final <- paste0(\"value ~ \",mvm.model,\" + Error(Subj/\",wsVars.model,\")\")\n  }\n  if(orig.plot == \"orig\" & is.na(wsVars.model)){\n    model.final <- paste0(\"value ~ \",mvm.model,\" + Error(Subj)\")\n  }\n\n  #####################\n  ## stats for box plots as selected\n  if(orig.plot == 'plot' & box.scatter == \"Box\"){\n    if(bs_ws.split == \"Between\"){\n      if(is.null(bsVarsCat.sel)){\n        return(cat(\"Error: No between subjects variable selected!\"))\n      }\n      model.vars <- combn_paste_fun(bsVarsCat.sel,\"*\")\n      model.vars <- model.vars[length(model.vars)]\n      model.final <- paste0(\"value ~ \",model.vars,\" + Error(Subj)\")\n\n    } else if(bs_ws.split == \"Within\"){\n      if(is.null(wsVars.sel)){\n        return(cat(\"Error: No within subjects variable selected!\"))\n      }\n      model.vars <- combn_paste_fun(wsVars.sel,\"*\")\n      model.vars <- model.vars[length(model.vars)]\n      model.final <- paste0(\"value ~ 1\",\" + Error(Subj/\",model.vars,\")\")\n\n    } else if(bs_ws.split == \"Both\"){\n      if(is.null(bsVarsCat.sel) | is.null(wsVars.sel)){\n        return(cat(\"Error: Need between AND within subjects variables!\"))\n      }\n      model.vars <- varCombine(bsVarsCat.sel,wsVars.sel,bs_ws.split)\n      model.vars <- combn_paste_fun(model.vars,\"*\")\n      model.vars <- model.vars[length(model.vars)]\n      model.ws   <- combn_paste_fun(wsVars.sel,\"*\")\n      model.ws   <- model.ws[length(model.ws)]\n      model.final <- paste0(\"value ~ \",model.vars,\" + Error(Subj/\",model.ws,\")\")\n    }\n  }   ## end box\n\n  #####################\n  ## stats for interaction plots as selected\n  if(orig.plot == 'plot' & box.scatter == \"Interaction\"){\n    if(bs_ws.split == \"Between\"){\n      if(length(bsVarsCat.sel) != 2){\n        return(cat(\"Error: Need EXACTLY 2 categorical variables!!\"))\n      }\n      model.vars <- combn_paste_fun(bsVarsCat.sel,\"*\")\n      model.vars <- model.vars[length(model.vars)]\n      model.final <- paste0(\"value ~ \",model.vars,\" + Error(Subj)\")\n\n    } else if(bs_ws.split == \"Within\"){\n      if(length(wsVars.sel) != 2){\n        return(cat(\"Error: Need EXACTLY 2 categorical variables!!\"))\n      }\n      model.ws <- combn_paste_fun(wsVars.sel,\"*\")\n      model.ws <- model.ws[length(model.ws)]\n      model.final <- paste0(\"value ~ \",model.ws,\" + Error(Subj/\",model.ws,\")\")\n\n    } else if(bs_ws.split == \"Both\"){\n      model.vars <- varCombine(bsVarsCat.sel,wsVars.sel,bs_ws.split)\n      if(length(model.vars) != 2){\n        return(cat(\"Error: Need EXACTLY 2 categorical variables!!\"))\n      }\n      model.vars <- combn_paste_fun(model.vars,\"*\")\n      model.vars <- model.vars[length(model.vars)]\n      model.ws   <- combn_paste_fun(wsVars.sel,\"*\")\n      model.ws   <- model.ws[length(model.ws)]\n      model.final <- paste0(\"value ~ \",model.vars,\" + Error(Subj/\",model.ws,\")\")\n    }\n  }   ## end interaction\n\n  #####################\n  ## stats for scatter plots as selected\n\n  ## check for qVars and center them to mean or specified\n  if(stat.info == \"3dMVM\" & !is.na(qVars)){\n    if(is.na(SI.df$qVarCenters)){\n      center.str <- \"mean\"\n      for(i in 1:length(qVars)){\n        plot.df[,qVars[i]] <- scale(plot.df[[qVars[i]]],center=TRUE,scale=FALSE)\n      }\n    } else {   ## center by value\n      center.str <- SI.df$qVarCenters\n      qVars.cent <- as.numeric(unlist(tstrsplit(SI.df$qVarCenters,',')))\n      for(i in 1:length(qVars)){\n        plot.df[,qVars[i]] <- scale(plot.df[[qVars[i]]],\n                                    center=qVars.cent[[i]],scale=FALSE)\n      }\n    }\n  }   ## end centering\n\n  if(orig.plot == 'plot' & box.scatter == \"Scatter\"){\n    if(bs_ws.split == \"Between\"){\n      model.vars <- combn_paste_fun(bsVarsCat.sel,\"*\")\n      model.vars <- model.vars[length(model.vars)]\n      model.final <- paste0(\"value ~ \",model.vars,\"*\",qVars.sel,\" + Error(Subj)\")\n\n    } else if(bs_ws.split == \"Within\"){\n      model.ws <- combn_paste_fun(wsVars.sel,\"*\")\n      model.ws <- model.ws[length(model.ws)]\n      model.final <- paste0(\"value ~ \",model.ws,\"*\",qVars.sel,\" + Error(Subj/\",model.ws,\")\")\n\n    } else if(bs_ws.split == \"Both\"){\n      model.vars <- varCombine(bsVarsCat.sel,wsVars.sel,bs_ws.split)\n      model.vars <- combn_paste_fun(model.vars,\"*\")\n      model.vars <- model.vars[length(model.vars)]\n      model.ws   <- combn_paste_fun(wsVars.sel,\"*\")\n      model.ws   <- model.ws[length(model.ws)]\n      model.final <- paste0(\"value ~ \",model.vars,\"*\",qVars.sel,\" + Error(Subj/\",model.ws,\")\")\n    }\n\n  }   ## end scatter\n\n  ## print out\n  cat(paste0(clust.lab,'\\n\\n'))\n  cat(paste0('Full Model = ',model.final,'\\n\\n'))\n  if(stat.info == \"3dMVM\" & box.scatter == \"Scatter\"){\n    cat(paste0(SI.df$qVars,' centered to ',center.str,'\\n\\n'))\n  }\n  model.final <- as.formula(model.final)\n  anova.aov <- aov_car(model.final,plot.df,factorize=FALSE,type=SI.df$SS_type)\n  return(anova(anova.aov))\n}   ## end stat_fun\n\n## function for statistics table\nstat_desc <- function(plot.df,prefix,p_val,stat.info,clust.lab,\n                      bsVarsCat.sel,vox.vol,fixed.range,custom.range,\n                      qVars.sel,one.plot,col.pal,marker.size){\n\n  if(bsVarsCat.sel == \"None\"){\n    return(data.frame(message=\"No factor variables in main model.\"))\n  }\n  ## make sure there is something there there (and fill empty for reactive)\n  if(nrow(plot.df) == 0){ return(\"Please wait.\") }\n  table.out <- data.frame(message=\"Please wait.\")\n\n  if(stat.info == \"Ttest\"){\n    plot.df <- model.frame(value ~ Group,data=plot.df)\n    table.out <- describeBy(plot.df$value,plot.df$Group,digits=5,mat=TRUE)\n    table.out <- subset(table.out,\n                        select=-c(vars,item,trimmed,range,skew,kurtosis))\n\n  } else if(stat.info == \"3dMVM\" & bsVarsCat.sel != \"None\"){\n\n    ## make the model as text and do the anova\n    bsVarsCat.sel <- as.formula(paste0(\"value ~ \",bsVarsCat.sel))\n\n    ## get the data frame by the model\n    plot.df <- model.frame(bsVarsCat.sel,data=plot.df)\n\n    ## get summary stats by list of grouping variables\n    grp.names <- names(plot.df[2:length(plot.df)])\n    grp.list <- as.list(plot.df[2:length(plot.df)])\n    table.out <- describeBy(plot.df$value,grp.list,digits=5,mat=TRUE)\n    table.out <- subset(table.out,\n                        select=-c(vars,item,trimmed,range,skew,kurtosis))\n\n    ## rename the \"group1\" etc\n    for(i in 1:length(grp.names)){\n      names(table.out)[i] <- grp.names[i]\n    }\n  }   ## end 3dMVM\n  return(table.out)\n}   ## end stat description\n",
    "created" : 1505921361207.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1813418670",
    "id" : "E8A68651",
    "lastKnownWriteTime" : 1505930769,
    "last_content_update" : 1505930769952,
    "path" : "~/research/ClusterExplorer/ClustExp_ShinyTemplate/stat_functions.R",
    "project_path" : "stat_functions.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}