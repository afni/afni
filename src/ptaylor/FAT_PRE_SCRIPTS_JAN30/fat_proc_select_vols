#!/bin/tcsh -ef

# written by PA Taylor (NIMH, NIH, USA)
# started March, 2017

# --------------------- revision history -------------------------
#
set version   = "1.0";    set rev_dat   = "March 29, 2017"
#   + inception
#
# ---------------------------------------------------------------

set this_prog = "fat_proc_select_vols"
set here      = $PWD

# ----------------- find AFNI and set viewer ---------------------

# find AFNI binaries directory and viewer location
set adir      = ""
set my_viewer = ""
which afni >& /dev/null
if ( $status ) then
    echo "** Cannot find 'afni' (?!)."
    goto BAD_EXIT
else
    set aa   = `which afni`
    set adir = $aa:h
endif

# default location of viewer: user could modify!
set my_viewer   = "$adir/@chauffeur_afni"
set my_selector = "$adir/@djunct_dwi_selector.bash"

# ----------------------- set defaults --------------------------

set idwi       = ""              # required input
set iimg       = ""              # required input
set obads      = ""              # NOT required input

set odir       = ""
set opref      = "indti"

set DO_VIEWER  = 1               # def: do viewing
set DO_CLEAN   = 1
set wdir       = "__WORKING_maptodti"
set output_cmd = 1               # def: output copy of this command
set cmd_file   = ""              # def: same name as viewer
set qc_prefix  = ""              # def: autoname; user can enter
set postfix    = "dti"           # stick into name

# ------------------- process options, a la rr ----------------------

if ( $#argv == 0 ) goto SHOW_HELP

set ac = 1
while ( $ac <= $#argv )
    # terminal options
    if ( ("$argv[$ac]" == "-h" ) || ("$argv[$ac]" == "-help" )) then
        goto SHOW_HELP
    endif
    if ( "$argv[$ac]" == "-ver" ) then
        goto SHOW_VERSION
    endif

    # --------------- input dset(s) ----------------
    # input dwi set
    if ( "$argv[$ac]" == "-in_dwi" ) then
        if ( $ac >= $#argv ) goto FAIL_MISSING_ARG
        @ ac += 1
        set idwi = "$argv[$ac]"

    # input dwi set
    else if ( "$argv[$ac]" == "-in_img" ) then
        if ( $ac >= $#argv ) goto FAIL_MISSING_ARG
        @ ac += 1
        set iimg = "$argv[$ac]"

    # can edit a pre-existing text file
    else if ( "$argv[$ac]" == "-in_bads" ) then
        if ( $ac >= $#argv ) goto FAIL_MISSING_ARG
        @ ac += 1
        set obads = "$argv[$ac]"

    # ----------------- outputs ---------------------

    else if ( "$argv[$ac]" == "-outdir" ) then
        if ( $ac >= $#argv ) goto FAIL_MISSING_ARG
        @ ac += 1
        set odir = "$argv[$ac]"

    else if ( "$argv[$ac]" == "-prefix" ) then
        if ( $ac >= $#argv ) goto FAIL_MISSING_ARG
        @ ac += 1
        set opref = "$argv[$ac]"

    # ------------------- other opts ---------------

    # ? make a flag to chop the input DWI if necessary?

    else if ( "$argv[$ac]" == "-no_cmd_out" ) then
        set output_cmd = 0

    else if ( "$argv[$ac]" == "-no_clean" ) then
        set DO_CLEAN =0 

    else
        echo "** unexpected option #$ac = '$argv[$ac]'"
        goto BAD_EXIT

    endif
    @ ac += 1
end

# =======================================================================
# ============================ ** SETUP ** ==============================
# =======================================================================

# ============================ input files ==============================

echo "++ Start script version: $version"

# NEED this input
if ( "$idwi" == "" ) then
    echo "** ERROR: no t1w file input?!"
    goto BAD_EXIT
endif

# make sure we can read volumes OK
foreach ff ( "$idwi" )
    set check = `3dinfo "$ff"`
    if ( "$#check" == "0" ) then
        echo "** ERROR: can't find input file:  $ff !"
        goto BAD_EXIT
    else
        echo "++ Found input file:   $ff"
    endif
end

# ========================= output dir ==========================
 
# check output directory, use input one if nothing given

if ( "$odir" == "" ) then
    # default output dir, if nothing input; it must exist already,
    # because a file is in it

    set odir = `dirname "$idwi"`
    echo "\n++ No output directory specified by the user."
    echo "++ Using the input T1w file's directory by default:"
    echo "\t$odir"
else
    if ( ! -e $odir ) then
        echo "++ Making new output directory: $odir"
        mkdir $odir
    endif
endif

set wdir = "$odir/$wdir"

# make the working directory
if ( ! -e $wdir ) then
    echo "++ Making working directory: $wdir"
    mkdir $wdir
else
    echo "+* WARNING: Somehow found a premade working directory (?):"
    echo "      $wdir"
endif

# ========================= output fnames ==========================

set ocmd   = "${opref}_cmd.txt"      # name for output command

## !!!!!!
if ( "$obads" == "" ) then

    set obads  = "${opref}_bad.txt"

    if ( -e "$odir/$obads" ) then
        echo ""
        echo "** ERROR! File for listing 'bads' exists already: $odir/$obads"
        echo "   ---> If you want to add to a list you started previously,"
        echo "        you must use the '-in_bads ...' option."
        echo "        (Sorry, but hopefully this prevents mistakenly"
        echo "        appending to preexisting lists.)\n"
        goto BAD_EXIT
    endif
else
    if ( -e "$odir/$obads" ) then
        echo ""
        echo "+* WARNING! Just so you know the file: $odir/$obads"
        echo "   exists already!  I assume you know that you will append to"
        echo "   it, and that you want to do so (because I assume all users"
        echo "   read help files as much as *I* do!)"
        echo "   Ooook, carrying on, then.\n"
    endif
endif

# =======================================================================
# =========================== ** PROCESS ** =============================
# =======================================================================

echo "\n-----> STARTING $this_prog ---->"

# ---------------------------- CMD ---------------------------------

echo "\n\nThis command:"
echo "$this_prog $argv\n\n"

if ( "$cmd_file" == "" ) then
    set cmd_file = "$odir/$ocmd"
endif

# copy original command:
# dump copy of command into workdir/..
if ( $output_cmd == 1 ) then
    echo "++ Echoing the command to: $cmd_file"

    echo "### Executed from the directory location:"  > $cmd_file
    echo "# $here\n"            >> $cmd_file
    echo "### The command was:" >> $cmd_file
    echo "# $this_prog $argv"   >> $cmd_file
    echo "\n"                   >> $cmd_file
endif

# --------------------- start proc ---------------------------

echo "++ Call selector:"
echo "   $my_selector $idwi $iimg $obads\n"

$my_selector "$idwi" "$iimg" "$obads"

if ( 0 ) then

    set vedge = $wdir/f10_edges.nii

    echo "++ More QC images: b0 on initial ref."
    3dedge3                         \
        -overwrite                  \
        -prefix $vedge              \
        -input  $odir/$ot1w

    if( $qc_prefix == "" ) then
        set vpref0 = ${opref}_${postfix}_qc00_t1wEt2w
        set vpref1 = ${opref}_${postfix}_qc01_t1won2w
    else
        set vpref0 = ${qc_prefix}_${postfix}_qc00_t1wEt2w 
        set vpref1 = ${qc_prefix}_${postfix}_qc01_t1won2w
    endif

    echo "\n\n"
    echo "++ QC image 00 ($odir/$ot1w edges on $it2w): $vpref0"
    echo "\n\n"
    # need to put '[0]' on $iref?
    $my_viewer                            \
        -ulay "$it2w"                     \
        -ulay_range "2%" "98%"            \
        -olay "$vedge"                    \
        -func_range_perc 50               \
        -pbar_posonly                     \
        -cbar "red_monochrome"            \
        -opacity 6                        \
        -prefix $vpref0                   \
        -outdir "$odir"                   \
        -montx 5 -monty 3                 \
        -set_xhairs OFF                   \
        -label_mode 1 -label_size 3       \
        -do_clean 

    echo "\n\n"
    echo "++ QC image 01 ($odir/$ot1w olay on $it2w): $vpref1"
    echo "\n\n"

    $my_viewer                            \
        -ulay "$it2w"                     \
        -ulay_range "2%" "98%"            \
        -olay "$odir/$ot1w"               \
        -pbar_posonly                     \
        -opacity 4                        \
        -prefix $vpref1                   \
        -outdir "$odir"                   \
        -montx 5 -monty 3                 \
        -set_xhairs OFF                   \
        -label_mode 1 -label_size 3       \
        -do_clean 

    # for NN
    foreach ff ( ${list_ofNN} )
        echo "++ QC imaging for the NN followers dset list:"
        echo "    ${list_ofNN}"

        set pp = `3dinfo -prefix_noext $ff`
        if( $qc_prefix == "" ) then
            set vprefnn = ${opref}_${postfix}_qc_$pp
        else
            set vprefnn = ${qc_prefix}_${postfix}_qc_$pp
        endif

        $my_viewer                            \
            -ulay "$it2w"                     \
            -ulay_range "2%" "98%"            \
            -olay "$ff"                       \
            -pbar_posonly                     \
            -cbar "ROI_i256"                  \
            -opacity 4                        \
            -prefix $vprefnn                  \
            -outdir "$odir"                   \
            -montx 5 -monty 3                 \
            -set_xhairs OFF                   \
            -label_mode 1 -label_size 3       \
            -do_clean 
    end

    # for WS5
    foreach ff ( ${list_ofWS5} )
        echo "++ QC imaging for the wsinc5 followers dset list:"
        echo "    ${list_ofWS5}"

        set pp = `3dinfo -prefix_noext $ff`
        if( $qc_prefix == "" ) then
            set vprefnn = ${opref}_${postfix}_qc_$pp
        else
            set vprefnn = ${qc_prefix}_${postfix}_qc_$pp
        endif

        $my_viewer                            \
            -ulay "$it2w"                     \
            -ulay_range "2%" "98%"            \
            -olay "$ff"                       \
            -pbar_posonly                     \
            -cbar "Viridis"                   \
            -opacity 4                        \
            -prefix $vprefnn                  \
            -outdir "$odir"                   \
            -montx 5 -monty 3                 \
            -set_xhairs OFF                   \
            -label_mode 1 -label_size 3       \
            -do_clean 
    end

endif


if ( 0 ) then
# clean, by default
if ( $DO_CLEAN ) then
    echo "\n++ Cleaning working directory!\n"
    \rm -rf $wdir
else
    echo "\n++ NOT removing working directory '$wdir'.\n"
endif

# final messages
echo "++ The final data set is here:  $odir/$ot1w"
echo "++ The final spatial dims are:  $fdims[1] $fdims[2] $fdims[3]"
echo "++ The spatial resolution is:   $fres[1] $fres[2] $fres[3]"


endif

# ---------------------------------------------------------------------
goto GOOD_EXIT

# ========================================================================
# ========================================================================

SHOW_HELP:
cat << EOF
# -----------------------------------------------------------------------

 This program is for building a selector string for AFNI subbricks
 and/or 1D text files.  It makes use of J. Rajendra's
 ``@djunct_dwi_selector.sh`` script to make a list of 'bad' volume
 indices by clicking on individual volumes in a montage image.  Pretty
 cool.

 In the end, a selector string of volumes *to keep* (i.e., the
 complement of the set of indices chosen with clicks) is output to
 screen as well as stored in a text file.

  Ver. $version (PA Taylor, ${rev_dat})

# ----------------------------------------------------------------------

  OUTPUT:

    + text file with AFNI-usable selector string, which can be put
      into either square brackets [] or curly brackets {}, whichever
      is appropriate for a given application.

# ----------------------------------------------------------------------

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  RUNNING:

    $this_prog \
      {-in_source SSS}                               \
      {-in_base   DDD}                               \
      {-outdir    ODIR}                              \
      {-prefix    PPP}                               \
      {-followers_NN      DSET01 DSET02 DSET03 ...}  \
      {-followers_wsinc5  DSET1 DSET2 DSET3 ...}     \
      {-no_cmd_out}                                  \
      {-no_clean} 

  where:

   -in_source SSS :T1w volume (required); 'source' volume from which we
                   are mapping, such as an anatomical volume in whose
                   space ROIs might have been defined.  SSS gets
                   mapped into the '-in_base BBB' volume's space.
   -in_base BBB   :DWI reference volume (required; should be from same
                   subject as SSS), such as the b=0 (or minimally DWed
                   volume), for aligning to; subbrick selections are
                   allowed, so that dwi_dwi.nii'[0]', for example,
                   would be allowed.  This is the base dset for the
                   alignment, with the purpose to bring other volumes
                   into the DWI/DTI space (see the '-followers* ...'
                   options, below).  **NOTE**: BBB and SSS should be
                   from the same subject by this function, because
                   only affine alignment with 3dAllineate is
                   performed!

   -outdir  ODIR  :can specify output directory for all created 
                   dsets (default is T1W volume's directory).                
   -prefix  PPP   :output prefix for files and snapshots.  

   -followers_NN  DSET01 DSET02 DSET03 ...
                  :apply the same transformation to 'follower' data
                   sets; one or more dsets can be listed, with each
                   assumed to overlay on the T1W source set. The 'NN'
                   interpolation of 3dAllineate is applied to these
                   dsets, so that integer values remain integer
                   valued; thus, these might be dsets with ROI maps
                   already created.  NB: subbrick selectors are not
                   allowed on the DSETs here at present.  Labeltables 
                   attached to these dsets do get propagated, as well.
   -followers_wsinc5  DSET1 DSET2 DSET3 ...
                   similar to the above '-followers_NN ...', except in
                   this case the final applied mapping is 'wsinc5', which
                   is appropriate, for example, for floating point values.
                   Again, a list of one or more volumes (sans subbrick
                   selectors) can be provided here.  No labeltable is
                   propagated for these sets (I doubt they would have one,
                   anyways).

   -no_cmd_out    :don't save the command line call of this program
                   and the location where it was run (otherwise, it is
                   saved by default in the ODIR/).                     
   -no_clean      :no not delete temporary working directory (default is 
                   to remove it to save disk space).

# ----------------------------------------------------------------------

  EXAMPLE


# -----------------------------------------------------------------------

EOF

    goto GOOD_EXIT

SHOW_VERSION:
    echo "version  $version (${rev_dat})"
    goto GOOD_EXIT

BAD_EXIT:
    exit 1

# send everyone here, in case there is any cleanup to do
GOOD_EXIT:
    exit 0
