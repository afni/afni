# define SEOS 1
# define SCOMMENT 2
# define SLABEL 3
# define SUNKNOWN 4
# define SHOLLERITH 5
# define SICON 6
# define SRCON 7
# define SDCON 8
# define SBITCON 9
# define SOCTCON 10
# define SHEXCON 11
# define STRUE 12
# define SFALSE 13
# define SNAME 14
# define SNAMEEQ 15
# define SFIELD 16
# define SSCALE 17
# define SINCLUDE 18
# define SLET 19
# define SASSIGN 20
# define SAUTOMATIC 21
# define SBACKSPACE 22
# define SBLOCK 23
# define SCALL 24
# define SCHARACTER 25
# define SCLOSE 26
# define SCOMMON 27
# define SCOMPLEX 28
# define SCONTINUE 29
# define SDATA 30
# define SDCOMPLEX 31
# define SDIMENSION 32
# define SDO 33
# define SDOUBLE 34
# define SELSE 35
# define SELSEIF 36
# define SEND 37
# define SENDFILE 38
# define SENDIF 39
# define SENTRY 40
# define SEQUIV 41
# define SEXTERNAL 42
# define SFORMAT 43
# define SFUNCTION 44
# define SGOTO 45
# define SASGOTO 46
# define SCOMPGOTO 47
# define SARITHIF 48
# define SLOGIF 49
# define SIMPLICIT 50
# define SINQUIRE 51
# define SINTEGER 52
# define SINTRINSIC 53
# define SLOGICAL 54
# define SNAMELIST 55
# define SOPEN 56
# define SPARAM 57
# define SPAUSE 58
# define SPRINT 59
# define SPROGRAM 60
# define SPUNCH 61
# define SREAD 62
# define SREAL 63
# define SRETURN 64
# define SREWIND 65
# define SSAVE 66
# define SSTATIC 67
# define SSTOP 68
# define SSUBROUTINE 69
# define STHEN 70
# define STO 71
# define SUNDEFINED 72
# define SWRITE 73
# define SLPAR 74
# define SRPAR 75
# define SEQUALS 76
# define SCOLON 77
# define SCOMMA 78
# define SCURRENCY 79
# define SPLUS 80
# define SMINUS 81
# define SSTAR 82
# define SSLASH 83
# define SPOWER 84
# define SCONCAT 85
# define SAND 86
# define SOR 87
# define SNEQV 88
# define SEQV 89
# define SNOT 90
# define SEQ 91
# define SLT 92
# define SGT 93
# define SLE 94
# define SGE 95
# define SNE 96
# define SENDDO 97
# define SWHILE 98
# define SSLASHD 99
# define SBYTE 100

/* # line 125 "gram.in" */
#include "defs.h"
#include "p1defs.h"

static int nstars;			/* Number of labels in an
					   alternate return CALL */
static int datagripe;
static int ndim;
static int vartype;
int new_dcl;
static ftnint varleng;
static struct Dims dims[MAXDIM+1];
extern struct Labelblock **labarray;	/* Labels in an alternate
						   return CALL */
extern int maxlablist;

/* The next two variables are used to verify that each statement might be reached
   during runtime.   lastwasbranch   is tested only in the defintion of the
   stat:   nonterminal. */

int lastwasbranch = NO;
static int thiswasbranch = NO;
extern ftnint yystno;
extern flag intonly;
static chainp datastack;
extern long laststfcn, thisstno;
extern int can_include;	/* for netlib */
extern struct Primblock *primchk Argdcl((expptr));

#define ESNULL (Extsym *)0
#define NPNULL (Namep)0
#define LBNULL (struct Listblock *)0

 static void
pop_datastack(Void) {
	chainp d0 = datastack;
	if (d0->datap)
		curdtp = (chainp)d0->datap;
	datastack = d0->nextp;
	d0->nextp = 0;
	frchain(&d0);
	}


/* # line 171 "gram.in" */
typedef union
#ifdef __cplusplus
	YYSTYPE
#endif
	{
	int ival;
	ftnint lval;
	char *charpval;
	chainp chval;
	tagptr tagval;
	expptr expval;
	struct Labelblock *labval;
	struct Nameblock *namval;
	struct Eqvchain *eqvval;
	Extsym *extval;
	} YYSTYPE;

#include <malloc.h>
#include <memory.h>
#include <unistd.h>
#include <values.h>

#ifdef __cplusplus

#ifndef yyerror
	void yyerror(const char *);
#endif
#ifndef yylex
	extern "C" int yylex(void);
#endif
	int yyparse(void);

#endif
#define yyclearin yychar = -1
#define yyerrok yyerrflag = 0
extern int yychar;
extern int yyerrflag;
YYSTYPE yylval;
YYSTYPE yyval;
typedef int yytabelem;
#ifndef YYMAXDEPTH
#define YYMAXDEPTH 150
#endif
#if YYMAXDEPTH > 0
int yy_yys[YYMAXDEPTH], *yys = yy_yys;
YYSTYPE yy_yyv[YYMAXDEPTH], *yyv = yy_yyv;
#else	/* user does initial allocation */
int *yys;
YYSTYPE *yyv;
#endif
static int yymaxdepth = YYMAXDEPTH;
# define YYERRCODE 256
yytabelem yyexca[] ={
-1, 1,
	0, -1,
	-2, 0,
-1, 20,
	1, 38,
	-2, 229,
-1, 24,
	1, 42,
	-2, 229,
-1, 123,
	6, 241,
	-2, 229,
-1, 151,
	1, 245,
	-2, 189,
-1, 175,
	1, 266,
	78, 266,
	-2, 189,
-1, 224,
	77, 174,
	-2, 140,
-1, 246,
	74, 229,
	-2, 226,
-1, 272,
	1, 287,
	-2, 144,
-1, 276,
	1, 296,
	78, 296,
	-2, 146,
-1, 329,
	77, 175,
	-2, 142,
-1, 359,
	1, 268,
	14, 268,
	74, 268,
	78, 268,
	-2, 190,
-1, 437,
	91, 0,
	92, 0,
	93, 0,
	94, 0,
	95, 0,
	96, 0,
	-2, 154,
-1, 454,
	1, 290,
	78, 290,
	-2, 144,
-1, 456,
	1, 292,
	78, 292,
	-2, 144,
-1, 458,
	1, 294,
	78, 294,
	-2, 144,
-1, 460,
	1, 297,
	78, 297,
	-2, 145,
-1, 505,
	78, 290,
	-2, 144,
	};
# define YYNPROD 302
# define YYLAST 1385
yytabelem yyact[]={

   238,   275,   472,   318,   317,   413,   421,   298,   471,   305,
   414,   398,   387,   358,   129,   267,   357,   327,   293,   400,
   253,   202,   296,   230,   399,   223,   304,   100,     5,   117,
    17,   265,   185,   204,   314,   274,   200,   211,   104,   271,
   119,   337,   203,   184,   261,   121,   237,   120,   107,   235,
   196,   102,   112,   122,   397,   513,   104,   105,   166,   167,
   335,   336,   337,   343,   342,   341,   340,   339,   191,   344,
   346,   345,   348,   347,   349,   396,   312,   158,   106,   158,
   310,   273,   166,   167,   259,   260,   261,   262,   115,   130,
   279,   397,   131,   132,   133,   134,   536,   136,   522,   476,
   484,   138,   466,   166,   167,   335,   336,   337,   343,   342,
   341,   340,   339,   540,   344,   346,   345,   348,   347,   349,
   103,    95,   319,   156,   295,   156,   335,   336,   337,   118,
   187,   188,   259,   260,   261,   104,    96,    97,    98,   526,
   186,   523,   410,   101,   231,   241,   241,   409,   195,   194,
   528,   212,   485,   447,   481,   158,   463,   220,   258,   158,
   244,   240,   242,   166,   167,   335,   336,   337,   214,    99,
   221,   219,   216,   158,   166,   167,   335,   336,   337,   343,
   342,   341,   215,   104,   158,   344,   346,   345,   348,   347,
   349,   166,   167,   335,   336,   337,   343,   103,   103,   103,
   103,   156,   190,   101,   121,   156,   120,   193,   462,   104,
   197,   198,   199,   461,   372,   321,   322,   207,   278,   156,
   301,   189,   289,   300,   325,   316,   329,   276,   276,   331,
   156,   453,   334,   197,   217,   218,   351,   309,   311,   444,
   353,   354,   334,   269,   290,   355,   350,   266,   429,   246,
   258,   248,   482,   158,   251,   483,   287,   288,   363,   158,
   158,   158,   158,   158,   258,   258,   469,   324,   378,   470,
   291,   280,   281,   282,   356,   464,   334,   295,   465,   379,
   451,     4,   377,   428,   258,   166,   167,   259,   260,   261,
   262,   103,   233,   448,   294,   376,   447,   270,   373,   156,
   401,   374,   375,   208,   178,   156,   156,   156,   156,   156,
   118,   393,   315,   382,   320,   113,   418,   407,   197,   419,
   408,   391,   334,   334,   392,   351,   334,   276,   111,   425,
   334,   151,   334,   175,   411,   231,   433,   434,   435,   436,
   437,   438,   439,   440,   441,   442,   404,   157,   110,   402,
   360,   406,   334,   361,   334,   334,   334,   432,   389,   381,
   109,   108,   158,   258,   334,   423,   420,   258,   258,   258,
   258,   258,   388,   236,   383,   384,   332,   495,   222,   333,
   334,   224,   449,   423,   371,   537,   533,   532,   452,   166,
   167,   259,   260,   261,   262,   531,   527,   473,   401,   530,
   525,   403,   197,   166,   167,   259,   260,   261,   156,   475,
   493,   468,   417,   467,   427,   104,   297,   446,   422,   137,
   480,   477,   487,   104,   489,   491,   276,   276,   276,   150,
   241,   497,   430,   385,   334,   334,   334,   334,   334,   334,
   334,   334,   334,   334,   404,   498,   496,   402,   404,   488,
   155,   258,   155,   494,   486,   192,   308,   503,   455,   457,
   459,   501,   286,   500,   247,   506,   507,   508,   243,   452,
   272,   272,   473,   227,   334,   307,   502,   401,   509,   512,
   224,   201,   511,   269,   213,   517,   210,   516,   334,   518,
   334,   480,   334,   521,   294,   519,   515,   241,   334,   403,
   524,   514,   249,   403,   529,   172,   263,   171,   173,   177,
   142,   276,   276,   276,   330,   535,   534,   492,    30,   104,
   264,   315,   415,   404,   510,   538,   402,   352,   155,   388,
   334,   283,   155,   209,   245,   226,   334,    93,     6,   334,
   539,   250,    82,   455,   457,   459,   155,   268,    81,    80,
    79,   174,   124,    78,   541,   504,    77,   155,    76,    60,
    49,    48,    45,   504,   504,   504,    33,   114,   206,   412,
   380,   205,   395,   394,   299,   303,   479,   306,   403,   135,
   390,   313,   116,   504,    26,    25,   359,   520,    24,    23,
   320,   166,   167,   259,   260,   261,   262,    22,    21,   386,
   362,   285,     9,     8,     7,     2,   366,   367,   368,   369,
   370,   302,    20,   165,    51,   490,   352,   292,   229,   328,
   326,   416,    92,   256,    53,   338,   155,    19,    55,    37,
   225,     3,   155,   155,   155,   155,   155,     1,     0,     0,
   268,   460,     0,   268,   268,     0,   166,   167,   335,   336,
   337,   343,   342,   341,   340,   339,     0,   344,   346,   345,
   348,   347,   349,   166,   167,   335,   336,   337,   343,   454,
   456,   458,     0,     0,   344,   346,   345,   348,   347,   349,
     0,   306,     0,   445,     0,     0,     0,     0,   166,   167,
   335,   336,   337,   343,   342,   341,   340,   339,   352,   344,
   346,   345,   348,   347,   349,   443,     0,     0,     0,   450,
   166,   167,   335,   336,   337,   343,   342,   341,   340,   339,
     0,   344,   346,   345,   348,   347,   349,   166,   167,   335,
   336,   337,   343,   342,     0,   155,     0,   499,   344,   346,
   345,   348,   347,   349,     0,     0,   268,     0,     0,     0,
     0,     0,   431,     0,   505,   456,   458,   166,   167,   335,
   336,   337,   343,   342,   341,   340,   339,     0,   344,   346,
   345,   348,   347,   349,     0,     0,     0,     0,     0,     0,
   424,     0,   478,     0,   306,   166,   167,   335,   336,   337,
   343,   342,   341,   340,   339,     0,   344,   346,   345,   348,
   347,   349,   166,   167,   335,   336,   337,   343,   342,   341,
   340,   339,     0,   344,   346,   345,   348,   347,   349,     0,
     0,     0,     0,     0,     0,     0,     0,   268,   161,   162,
   163,   164,   170,   169,   168,   159,   160,   104,     0,     0,
     0,     0,    12,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,   306,    10,    56,    46,    73,
    86,    14,    61,    70,    91,    38,    66,    47,    42,    68,
    72,    31,    67,    35,    34,    11,    88,    36,    18,    41,
    39,    28,    16,    57,    58,    59,    50,    54,    43,    89,
    64,    40,    69,    44,    90,    29,    62,    85,    13,     0,
    83,    65,    52,    87,    27,    74,    63,    15,    73,     0,
    71,    84,    70,     0,     0,    66,     0,     0,    68,    72,
     0,    67,   161,   162,   163,   164,   170,   169,   168,   159,
   160,   104,     0,     0,     0,    32,     0,     0,    75,    64,
     0,    69,     0,     0,     0,     0,     0,     0,     0,     0,
    65,     0,     0,     0,    74,     0,     0,     0,     0,    71,
   161,   162,   163,   164,   170,   169,   168,   159,   160,   104,
     0,   161,   162,   163,   164,   170,   169,   168,   159,   160,
   104,     0,     0,     0,     0,     0,     0,    75,     0,     0,
     0,   234,     0,     0,     0,     0,     0,   166,   167,   364,
     0,   365,     0,     0,     0,     0,     0,   239,   161,   162,
   163,   164,   170,   169,   168,   159,   160,   104,     0,   161,
   162,   163,   164,   170,   169,   168,   159,   160,   104,   234,
   228,     0,     0,     0,     0,   166,   167,   232,     0,     0,
   234,     0,     0,     0,     0,   239,   166,   167,   474,     0,
     0,     0,     0,     0,    94,     0,   239,   161,   162,   163,
   164,   170,   169,   168,   159,   160,   104,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,   234,     0,     0,
     0,     0,     0,   166,   167,   232,   123,     0,   234,   126,
   127,   128,     0,   239,   166,   167,   426,     0,     0,     0,
     0,   139,   140,     0,   239,   141,     0,   143,   144,   145,
     0,     0,   146,   147,   148,     0,   149,     0,     0,     0,
     0,     0,     0,     0,     0,     0,   234,     0,     0,     0,
     0,     0,   166,   167,     0,     0,   179,   180,   181,   182,
   183,     0,   239,   161,   162,   163,   164,   170,   169,   168,
   159,   160,   104,     0,   161,   162,   163,   164,   170,   169,
   168,   159,   160,   104,     0,   161,   162,   163,   164,   170,
   169,   168,   159,   160,   104,   257,   161,   162,   163,   164,
   170,   169,   168,   159,   160,   104,     0,   161,   162,   163,
   164,   170,   169,   168,   159,   160,   104,   161,   162,   163,
   164,   170,   169,   168,   159,   160,   104,     0,     0,     0,
     0,     0,   277,     0,     0,     0,     0,     0,   166,   167,
     0,     0,     0,   323,     0,     0,     0,     0,   239,   166,
   167,     0,     0,     0,   252,     0,     0,     0,     0,   239,
   166,   167,   254,     0,   255,   154,     0,     0,     0,     0,
     0,   166,   167,   152,     0,   153,   252,     0,     0,     0,
     0,     0,   166,   167,   284,     0,   154,     0,     0,     0,
     0,     0,   166,   167,   176,   161,   162,   163,   164,   170,
   169,   168,   159,   160,   104,   161,   162,   163,   164,   170,
   169,   168,   159,   160,   104,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
    56,    46,     0,    86,     0,    61,     0,    91,     0,     0,
    47,     0,     0,     0,   405,     0,     0,     0,     0,    88,
   166,   167,     0,     0,   252,     0,    57,    58,    59,    50,
   166,   167,    89,     0,     0,     0,     0,    90,     0,    62,
    85,     0,     0,    83,     0,    52,    87,     0,     0,    63,
     0,   125,     0,     0,    84 };
yytabelem yypact[]={

-10000000,    25,   537,   838,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,
   532,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,   125,   505,   -21,
   283,   282,   270,   250,    65,   237,     5,   121,-10000000,-10000000,
-10000000,-10000000,-10000000,  1311,-10000000,-10000000,-10000000,     7,-10000000,-10000000,
-10000000,-10000000,-10000000,-10000000,-10000000,   505,-10000000,-10000000,-10000000,-10000000,
-10000000,   436,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,
-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,
-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,  1171,   431,  1192,   431,
   226,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,
-10000000,-10000000,-10000000,-10000000,-10000000,   505,   505,   505,   505,-10000000,
   505,-10000000,   381,-10000000,-10000000,   505,-10000000,   -38,   505,   505,
   505,   407,-10000000,-10000000,-10000000,   505,   225,-10000000,-10000000,-10000000,
-10000000,   519,   412,    65,-10000000,-10000000,   410,-10000000,-10000000,-10000000,
-10000000,   121,   505,   505,   407,-10000000,-10000000,   302,   406,   529,
-10000000,   399,   955,  1052,  1052,   394,   528,   505,   390,   505,
-10000000,-10000000,-10000000,-10000000,  1160,-10000000,-10000000,     2,  1280,-10000000,
-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,
-10000000,-10000000,  1160,   169,   219,-10000000,-10000000,  1138,  1138,-10000000,
-10000000,-10000000,-10000000,  1182,   388,-10000000,-10000000,   381,   381,   505,
-10000000,-10000000,   195,   342,-10000000,    65,-10000000,   342,-10000000,-10000000,
-10000000,   505,-10000000,   401,-10000000,   382,   887,    -3,   121,    -7,
   505,   528,    24,  1052,  1149,-10000000,   505,-10000000,-10000000,-10000000,
-10000000,-10000000,  1052,-10000000,  1052,   443,-10000000,  1052,-10000000,   301,
-10000000,   722,   528,-10000000,  1052,-10000000,-10000000,-10000000,  1052,  1052,
-10000000,   722,-10000000,  1052,-10000000,-10000000,    65,   528,-10000000,   511,
   275,-10000000,  1280,-10000000,-10000000,-10000000,   917,-10000000,  1280,  1280,
  1280,  1280,  1280,   -40,   309,   136,   409,-10000000,-10000000,   409,
   409,-10000000,   217,   204,   190,   722,-10000000,  1138,-10000000,-10000000,
-10000000,-10000000,-10000000,     2,-10000000,-10000000,   358,-10000000,-10000000,   381,
-10000000,-10000000,   246,-10000000,-10000000,-10000000,     7,-10000000,   -24,  1270,
   505,-10000000,   242,-10000000,    64,-10000000,-10000000,   401,   508,-10000000,
   505,-10000000,-10000000,   241,-10000000,   290,-10000000,-10000000,-10000000,   344,
   289,   705,   722,  1014,-10000000,   722,   339,   206,   170,   722,
   505,   677,-10000000,  1003,  1052,  1052,  1052,  1052,  1052,  1052,
  1052,  1052,  1052,  1052,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,
-10000000,   630,   161,   -43,   583,   608,   343,   218,-10000000,-10000000,
-10000000,  1160,   205,   722,-10000000,-10000000,    50,   -40,   -40,   -40,
   323,-10000000,   409,   136,   153,   136,  1138,  1138,  1138,   566,
   135,   130,    78,-10000000,-10000000,-10000000,   200,-10000000,    26,-10000000,
   342,-10000000,    42,-10000000,   191,   966,-10000000,  1270,-10000000,-10000000,
    17,   823,-10000000,-10000000,-10000000,  1052,-10000000,-10000000,   505,-10000000,
   401,    76,   177,-10000000,    19,-10000000,    74,-10000000,-10000000,   505,
  1052,    65,  1052,  1052,   447,-10000000,   335,   303,  1052,  1052,
-10000000,   528,-10000000,    44,   -43,   -43,   -43,   111,    94,    94,
   647,   583,    83,-10000000,  1052,-10000000,   528,   528,    65,-10000000,
     2,-10000000,-10000000,   409,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,
-10000000,  1138,  1138,  1138,-10000000,   515,   510,     7,-10000000,-10000000,
   966,-10000000,-10000000,   -22,-10000000,-10000000,  1270,-10000000,-10000000,-10000000,
-10000000,   401,-10000000,   508,   508,   505,-10000000,   722,    24,    23,
    63,   722,-10000000,-10000000,-10000000,  1052,   325,   722,    61,   321,
    75,-10000000,  1052,   324,   307,   321,   320,   312,   311,-10000000,
-10000000,-10000000,-10000000,   966,-10000000,-10000000,    13,   310,-10000000,-10000000,
-10000000,-10000000,-10000000,  1052,-10000000,-10000000,   528,-10000000,-10000000,   722,
-10000000,-10000000,-10000000,-10000000,-10000000,   722,-10000000,-10000000,   722,    35,
   528,-10000000 };
yytabelem yypgo[]={

     0,   637,   631,    13,   630,    81,    15,    30,   629,   628,
   627,    10,     0,   625,   624,   623,    14,   622,     9,    26,
   621,   620,   619,     3,     4,   618,    68,   617,   615,    31,
    39,    35,    25,   101,    18,   614,    50,   373,     1,   292,
    17,   347,   254,     2,    19,    24,    23,    49,    46,   613,
   612,    40,    32,    43,   611,   605,   604,   603,   602,  1054,
   121,   601,   599,    12,   598,   597,   589,   588,   585,   584,
   582,    53,   581,    27,   580,    22,    42,     7,    37,     6,
    36,   579,    21,   576,   574,    11,    29,    34,   573,   572,
     8,    16,    33,   571,   569,   568,     5,   567,   518,   566,
   562,   561,   560,   559,   558,   429,   556,   553,   551,   550,
   549,   548,    90,   542,   541,    20 };
yytabelem yyr1[]={

     0,     1,     1,    55,    55,    55,    55,    55,    55,    55,
     2,    56,    56,    56,    56,    56,    56,    56,    60,    52,
    33,    53,    53,    61,    61,    62,    62,    63,    63,    26,
    26,    26,    27,    27,    34,    34,    17,    57,    57,    57,
    57,    57,    57,    57,    57,    57,    57,    57,    57,    10,
    10,    10,    74,     7,     8,     9,     9,     9,     9,     9,
     9,     9,     9,     9,     9,     9,     9,    16,    16,    16,
    50,    50,    50,    50,    51,    51,    64,    64,    65,    65,
    66,    66,    80,    54,    54,    67,    67,    81,    82,    76,
    83,    84,    77,    77,    85,    85,    45,    45,    45,    70,
    70,    86,    86,    72,    72,    87,    36,    18,    18,    19,
    19,    75,    75,    89,    88,    88,    90,    90,    43,    43,
    91,    91,     3,    68,    68,    92,    92,    95,    93,    94,
    94,    96,    96,    11,    69,    69,    97,    20,    20,    71,
    21,    21,    22,    22,    38,    38,    38,    39,    39,    39,
    39,    39,    39,    39,    39,    39,    39,    39,    39,    39,
    39,    12,    12,    13,    13,    13,    13,    13,    13,    37,
    37,    37,    37,    32,    40,    40,    44,    44,    48,    48,
    48,    48,    48,    48,    48,    47,    49,    49,    49,    41,
    41,    42,    42,    42,    42,    42,    42,    42,    42,    58,
    58,    58,    58,    58,    58,    58,    58,    58,    99,    23,
    24,    24,    98,    98,    98,    98,    98,    98,    98,    98,
    98,    98,    98,     4,   100,   101,   101,   101,   101,    73,
    73,    35,    25,    25,    46,    46,    14,    14,    28,    28,
    59,    78,    79,   102,   103,   103,   103,   103,   103,   103,
   103,   103,   103,   103,   103,   103,   103,   103,   104,   111,
   111,   111,   106,   113,   113,   113,   108,   108,   105,   105,
   114,   114,   115,   115,   115,   115,   115,   115,    15,   107,
   109,   110,   110,    29,    29,     6,     6,    30,    30,    30,
    31,    31,    31,    31,    31,    31,     5,     5,     5,     5,
     5,   112 };
yytabelem yyr2[]={

     0,     0,     6,     5,     4,     5,     7,     7,     5,     3,
     3,     7,     9,     7,     9,     9,    11,     7,     1,     3,
     3,     1,     2,     4,     6,     2,     6,     2,     6,     1,
     5,     7,     3,     7,     3,     3,     3,     2,     2,     2,
     2,     2,     2,     2,     2,     3,     5,     3,    11,    15,
    11,    11,     1,     5,     3,     3,     3,     3,     3,     3,
     3,     3,     3,     3,     3,     3,     3,     1,     9,    13,
     7,     9,    11,     7,     3,     7,     7,     7,     7,     7,
     6,     6,     7,     3,     7,     6,     6,     1,    13,     1,
     1,     1,     4,     6,     3,     7,     2,     5,     2,     2,
     6,     3,     2,     2,     6,     7,     5,     3,    11,     3,
     7,     1,     6,     1,     4,     6,     3,     7,     3,     2,
     3,     7,     3,     7,     6,     8,     3,     1,     4,     2,
     6,     3,     7,     3,     2,     4,     9,     3,     7,     1,
     1,     3,     3,     7,     2,     7,     2,     2,     2,     7,
     7,     7,     7,     5,     7,     7,     7,     7,     7,     5,
     7,     3,     3,     3,     3,     3,     3,     3,     3,     3,
     5,     9,    11,    11,     1,     2,     3,     2,     3,     3,
     3,     3,     3,     3,     2,    11,     3,     3,     3,     2,
     7,     2,     2,     7,     7,     7,     7,     5,     7,     2,
    15,     9,     3,     5,     4,    13,     5,     5,    11,     7,
     2,     9,     9,    11,     4,     2,     3,    21,     3,     7,
     9,     7,     7,     3,     3,     7,     7,    15,    15,     0,
     2,     7,     3,     7,     2,     5,     3,     3,     3,     7,
     1,     1,     1,     3,     4,     5,     5,     5,     4,     5,
     5,     7,     9,     9,     5,     7,     3,     7,     6,     3,
     3,     3,     6,     3,     3,     3,     3,     3,     7,     7,
     2,     6,     3,     3,     3,     5,     5,     5,     3,     7,
     7,     9,     9,     3,     7,     3,    11,     3,     3,     2,
     7,     7,     7,     7,     7,     7,     3,     7,    11,    11,
    11,     1 };
yytabelem yychk[]={

-10000000,    -1,   -55,    -2,   256,     3,     1,   -56,   -57,   -58,
    18,    37,     4,    60,    23,    69,    44,    -7,    40,   -10,
   -50,   -64,   -65,   -66,   -67,   -68,   -69,    66,    43,    57,
   -98,    33,    97,   -99,    36,    35,    39,    -8,    27,    42,
    53,    41,    30,    50,    55,  -100,    20,    29,  -101,  -102,
    48,   -35,    64,   -14,    49,    -9,    19,    45,    46,    47,
  -103,    24,    58,    68,    52,    63,    28,    34,    31,    54,
    25,    72,    32,    21,    67,   100,  -104,  -106,  -107,  -109,
  -110,  -111,  -113,    62,    73,    59,    22,    65,    38,    51,
    56,    26,   -17,     5,   -59,   -60,   -60,   -60,   -60,    44,
   -73,    78,   -52,   -33,    14,    78,    99,   -73,    78,    78,
    78,    78,   -73,    78,   -97,    83,   -70,   -86,   -33,   -51,
    85,    83,   -71,   -59,   -98,    70,   -59,   -59,   -59,   -16,
    82,   -71,   -71,   -71,   -71,   -81,   -71,   -37,   -33,   -59,
   -59,   -59,    74,   -59,   -59,   -59,   -59,   -59,   -59,   -59,
  -105,   -42,    82,    84,    74,   -37,   -48,   -41,   -12,    12,
    13,     5,     6,     7,     8,   -49,    80,    81,    11,    10,
     9,  -105,    74,  -105,  -108,   -42,    82,  -105,    78,   -59,
   -59,   -59,   -59,   -59,   -53,   -52,   -53,   -52,   -52,   -60,
   -33,   -26,    74,   -33,   -76,   -51,   -36,   -33,   -33,   -33,
   -80,    74,   -82,   -76,   -92,   -93,   -95,   -33,    78,    14,
    74,   -78,   -73,    74,   -78,   -36,   -51,   -33,   -33,   -80,
   -82,   -92,    76,   -32,    74,    -4,     6,    74,    75,   -25,
   -46,   -38,    82,   -39,    74,   -47,   -37,   -48,   -12,    90,
   -40,   -38,   -40,    74,    -3,     6,   -33,    74,   -33,   -41,
  -114,   -42,    74,  -115,    82,    84,   -15,    15,   -12,    82,
    83,    84,    85,   -41,   -41,   -29,    78,    -6,   -37,    74,
    78,   -30,   -39,    -5,   -31,   -38,   -47,    74,   -30,  -112,
  -112,  -112,  -112,   -41,    82,   -61,    74,   -26,   -26,   -52,
   -71,    75,   -27,   -34,   -33,    82,   -75,    74,   -77,   -84,
   -73,   -75,   -54,   -37,   -19,   -18,   -37,    74,    74,    -7,
    83,   -86,    83,   -72,   -87,   -33,    -3,   -24,   -23,    98,
   -33,   -38,   -38,    74,   -36,   -38,   -21,   -40,   -22,   -38,
    71,   -38,    75,    78,   -12,    82,    83,    84,   -13,    89,
    88,    87,    86,    85,    91,    93,    92,    95,    94,    96,
    -3,   -38,   -39,   -38,   -38,   -38,   -73,   -91,    -3,    75,
    75,    78,   -41,   -38,    82,    84,   -41,   -41,   -41,   -41,
   -41,    75,    78,   -29,   -29,   -29,    78,    78,    78,   -38,
   -39,    -5,   -31,  -112,  -112,    75,   -62,   -63,    14,   -26,
   -74,    75,    78,   -16,   -88,   -89,    99,    78,   -85,   -45,
   -44,   -12,   -47,   -33,   -48,    74,   -36,    75,    78,    83,
    78,   -19,   -94,   -96,   -11,    14,   -20,   -33,    75,    78,
    76,   -79,    74,    76,    75,   -79,    82,    75,    77,    78,
   -33,    75,   -46,   -38,   -38,   -38,   -38,   -38,   -38,   -38,
   -38,   -38,   -38,    75,    78,    75,    74,    78,    75,  -115,
   -41,    75,    -6,    78,   -39,    -5,   -39,    -5,   -39,    -5,
    75,    78,    78,    78,    75,    78,    76,   -75,   -34,    75,
    78,   -90,   -43,   -38,    82,   -85,    82,   -44,   -37,   -83,
   -18,    78,    75,    78,    81,    78,   -87,   -38,   -73,   -38,
   -28,   -38,    70,    75,   -32,    74,   -40,   -38,    -3,   -39,
   -91,    -3,   -73,   -23,   -33,   -39,   -23,   -23,   -23,   -63,
    14,   -16,   -90,    77,   -45,   -44,   -77,   -23,   -96,   -11,
   -33,   -24,    75,    78,   -79,    75,    78,    75,    75,   -38,
    75,    75,    75,    75,   -43,   -38,    83,    75,   -38,    -3,
    78,    -3 };
yytabelem yydef[]={

     1,    -2,     0,     0,     9,    10,     2,     3,     4,     5,
     0,   240,     8,    18,    18,    18,    18,   229,     0,    37,
    -2,    39,    40,    41,    -2,    43,    44,    45,    47,   139,
   199,   240,   202,     0,   240,   240,   240,    67,   139,   139,
   139,   139,    87,   139,   134,     0,   240,   240,   215,   216,
   240,   218,   240,   240,   240,    54,   224,   240,   240,   240,
   243,   240,   236,   237,    55,    56,    57,    58,    59,    60,
    61,    62,    63,    64,    65,    66,     0,     0,     0,     0,
   256,   240,   240,   240,   240,   240,   259,   260,   261,   263,
   264,   265,     6,    36,     7,    21,    21,     0,     0,    18,
     0,   230,    29,    19,    20,     0,    89,     0,   230,     0,
     0,     0,    89,   127,   135,     0,    46,    99,   101,   102,
    74,     0,     0,    -2,   203,   204,     0,   206,   207,    53,
   241,     0,     0,     0,     0,    89,   127,     0,   169,     0,
   214,     0,     0,   174,   174,     0,     0,     0,     0,     0,
   244,    -2,   246,   247,     0,   191,   192,     0,     0,   178,
   179,   180,   181,   182,   183,   184,   161,   162,   186,   187,
   188,   248,     0,   249,   250,    -2,   267,   254,     0,   301,
   301,   301,   301,     0,    11,    22,    13,    29,    29,     0,
   139,    17,     0,   111,    91,   229,    73,   111,    77,    79,
    81,     0,    86,     0,   124,   126,     0,     0,     0,     0,
     0,     0,     0,     0,     0,    70,     0,    76,    78,    80,
    85,   123,     0,   170,    -2,     0,   223,     0,   219,     0,
   232,   234,     0,   144,     0,   146,   147,   148,     0,     0,
   221,   175,   222,     0,   225,   122,    -2,     0,   231,   272,
     0,   189,     0,   270,   273,   274,     0,   278,     0,     0,
     0,     0,     0,   197,   272,   251,     0,   283,   285,     0,
     0,   255,    -2,   288,   289,     0,    -2,     0,   257,   258,
   262,   279,   280,   301,   301,    12,     0,    14,    15,    29,
    52,    30,     0,    32,    34,    35,    67,   113,     0,     0,
     0,   106,     0,    83,     0,   109,   107,     0,     0,   128,
     0,   100,    75,     0,   103,     0,   242,   201,   210,     0,
     0,     0,   242,     0,    71,   212,     0,     0,   141,    -2,
     0,     0,   220,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,   163,   164,   165,   166,   167,   168,
   235,     0,   144,   153,   159,     0,     0,     0,   120,    -2,
   269,     0,     0,   275,   276,   277,   193,   194,   195,   196,
   198,   268,     0,   253,     0,   252,     0,     0,     0,     0,
   144,     0,     0,   281,   282,    23,     0,    25,    27,    16,
   111,    31,     0,    50,     0,     0,    51,     0,    92,    94,
    96,     0,    98,   176,   177,     0,    72,    82,     0,    90,
     0,     0,     0,   129,   131,   133,   136,   137,    48,     0,
     0,   229,     0,     0,     0,    68,     0,   171,   174,     0,
   213,     0,   233,   149,   150,   151,   152,    -2,   155,   156,
   157,   158,   160,   145,     0,   208,     0,     0,   229,   271,
   272,   190,   284,     0,    -2,   291,    -2,   293,    -2,   295,
    -2,     0,     0,     0,    24,     0,     0,    67,    33,   112,
     0,   114,   116,   119,   118,    93,     0,    97,    84,    91,
   110,     0,   125,     0,     0,     0,   104,   105,     0,     0,
   209,   238,   205,   242,   172,   174,     0,   143,     0,   144,
     0,   121,     0,     0,   169,    -2,     0,     0,     0,    26,
    28,    49,   115,     0,    95,    96,     0,     0,   130,   132,
   138,   200,   211,     0,    69,   173,     0,   185,   227,   228,
   286,   298,   299,   300,   117,   119,    88,   108,   239,     0,
     0,   217 };
typedef struct
#ifdef __cplusplus
	yytoktype
#endif
{ char *t_name; int t_val; } yytoktype;
#ifndef YYDEBUG
#	define YYDEBUG	0	/* don't allow debugging */
#endif

#if YYDEBUG

yytoktype yytoks[] =
{
	"SEOS",	1,
	"SCOMMENT",	2,
	"SLABEL",	3,
	"SUNKNOWN",	4,
	"SHOLLERITH",	5,
	"SICON",	6,
	"SRCON",	7,
	"SDCON",	8,
	"SBITCON",	9,
	"SOCTCON",	10,
	"SHEXCON",	11,
	"STRUE",	12,
	"SFALSE",	13,
	"SNAME",	14,
	"SNAMEEQ",	15,
	"SFIELD",	16,
	"SSCALE",	17,
	"SINCLUDE",	18,
	"SLET",	19,
	"SASSIGN",	20,
	"SAUTOMATIC",	21,
	"SBACKSPACE",	22,
	"SBLOCK",	23,
	"SCALL",	24,
	"SCHARACTER",	25,
	"SCLOSE",	26,
	"SCOMMON",	27,
	"SCOMPLEX",	28,
	"SCONTINUE",	29,
	"SDATA",	30,
	"SDCOMPLEX",	31,
	"SDIMENSION",	32,
	"SDO",	33,
	"SDOUBLE",	34,
	"SELSE",	35,
	"SELSEIF",	36,
	"SEND",	37,
	"SENDFILE",	38,
	"SENDIF",	39,
	"SENTRY",	40,
	"SEQUIV",	41,
	"SEXTERNAL",	42,
	"SFORMAT",	43,
	"SFUNCTION",	44,
	"SGOTO",	45,
	"SASGOTO",	46,
	"SCOMPGOTO",	47,
	"SARITHIF",	48,
	"SLOGIF",	49,
	"SIMPLICIT",	50,
	"SINQUIRE",	51,
	"SINTEGER",	52,
	"SINTRINSIC",	53,
	"SLOGICAL",	54,
	"SNAMELIST",	55,
	"SOPEN",	56,
	"SPARAM",	57,
	"SPAUSE",	58,
	"SPRINT",	59,
	"SPROGRAM",	60,
	"SPUNCH",	61,
	"SREAD",	62,
	"SREAL",	63,
	"SRETURN",	64,
	"SREWIND",	65,
	"SSAVE",	66,
	"SSTATIC",	67,
	"SSTOP",	68,
	"SSUBROUTINE",	69,
	"STHEN",	70,
	"STO",	71,
	"SUNDEFINED",	72,
	"SWRITE",	73,
	"SLPAR",	74,
	"SRPAR",	75,
	"SEQUALS",	76,
	"SCOLON",	77,
	"SCOMMA",	78,
	"SCURRENCY",	79,
	"SPLUS",	80,
	"SMINUS",	81,
	"SSTAR",	82,
	"SSLASH",	83,
	"SPOWER",	84,
	"SCONCAT",	85,
	"SAND",	86,
	"SOR",	87,
	"SNEQV",	88,
	"SEQV",	89,
	"SNOT",	90,
	"SEQ",	91,
	"SLT",	92,
	"SGT",	93,
	"SLE",	94,
	"SGE",	95,
	"SNE",	96,
	"SENDDO",	97,
	"SWHILE",	98,
	"SSLASHD",	99,
	"SBYTE",	100,
	"-unknown-",	-1	/* ends search */
};

char * yyreds[] =
{
	"-no such reduction-",
	"program : /* empty */",
	"program : program stat SEOS",
	"stat : thislabel entry",
	"stat : thislabel spec",
	"stat : thislabel exec",
	"stat : thislabel SINCLUDE filename",
	"stat : thislabel SEND end_spec",
	"stat : thislabel SUNKNOWN",
	"stat : error",
	"thislabel : SLABEL",
	"entry : SPROGRAM new_proc progname",
	"entry : SPROGRAM new_proc progname progarglist",
	"entry : SBLOCK new_proc progname",
	"entry : SSUBROUTINE new_proc entryname arglist",
	"entry : SFUNCTION new_proc entryname arglist",
	"entry : type SFUNCTION new_proc entryname arglist",
	"entry : SENTRY entryname arglist",
	"new_proc : /* empty */",
	"entryname : name",
	"name : SNAME",
	"progname : /* empty */",
	"progname : entryname",
	"progarglist : SLPAR SRPAR",
	"progarglist : SLPAR progargs SRPAR",
	"progargs : progarg",
	"progargs : progargs SCOMMA progarg",
	"progarg : SNAME",
	"progarg : SNAME SEQUALS SNAME",
	"arglist : /* empty */",
	"arglist : SLPAR SRPAR",
	"arglist : SLPAR args SRPAR",
	"args : arg",
	"args : args SCOMMA arg",
	"arg : name",
	"arg : SSTAR",
	"filename : SHOLLERITH",
	"spec : dcl",
	"spec : common",
	"spec : external",
	"spec : intrinsic",
	"spec : equivalence",
	"spec : data",
	"spec : implicit",
	"spec : namelist",
	"spec : SSAVE",
	"spec : SSAVE savelist",
	"spec : SFORMAT",
	"spec : SPARAM in_dcl SLPAR paramlist SRPAR",
	"dcl : type opt_comma name in_dcl new_dcl dims lengspec",
	"dcl : dcl SCOMMA name dims lengspec",
	"dcl : dcl SSLASHD datainit vallist SSLASHD",
	"new_dcl : /* empty */",
	"type : typespec lengspec",
	"typespec : typename",
	"typename : SINTEGER",
	"typename : SREAL",
	"typename : SCOMPLEX",
	"typename : SDOUBLE",
	"typename : SDCOMPLEX",
	"typename : SLOGICAL",
	"typename : SCHARACTER",
	"typename : SUNDEFINED",
	"typename : SDIMENSION",
	"typename : SAUTOMATIC",
	"typename : SSTATIC",
	"typename : SBYTE",
	"lengspec : /* empty */",
	"lengspec : SSTAR intonlyon expr intonlyoff",
	"lengspec : SSTAR intonlyon SLPAR SSTAR SRPAR intonlyoff",
	"common : SCOMMON in_dcl var",
	"common : SCOMMON in_dcl comblock var",
	"common : common opt_comma comblock opt_comma var",
	"common : common SCOMMA var",
	"comblock : SCONCAT",
	"comblock : SSLASH SNAME SSLASH",
	"external : SEXTERNAL in_dcl name",
	"external : external SCOMMA name",
	"intrinsic : SINTRINSIC in_dcl name",
	"intrinsic : intrinsic SCOMMA name",
	"equivalence : SEQUIV in_dcl equivset",
	"equivalence : equivalence SCOMMA equivset",
	"equivset : SLPAR equivlist SRPAR",
	"equivlist : lhs",
	"equivlist : equivlist SCOMMA lhs",
	"data : SDATA in_data datalist",
	"data : data opt_comma datalist",
	"in_data : /* empty */",
	"datalist : datainit datavarlist SSLASH datapop vallist SSLASH",
	"datainit : /* empty */",
	"datapop : /* empty */",
	"vallist : /* empty */",
	"vallist : val",
	"vallist : vallist SCOMMA val",
	"val : value",
	"val : simple SSTAR value",
	"value : simple",
	"value : addop simple",
	"value : complex_const",
	"savelist : saveitem",
	"savelist : savelist SCOMMA saveitem",
	"saveitem : name",
	"saveitem : comblock",
	"paramlist : paramitem",
	"paramlist : paramlist SCOMMA paramitem",
	"paramitem : name SEQUALS expr",
	"var : name dims",
	"datavar : lhs",
	"datavar : SLPAR datavarlist SCOMMA dospec SRPAR",
	"datavarlist : datavar",
	"datavarlist : datavarlist SCOMMA datavar",
	"dims : /* empty */",
	"dims : SLPAR dimlist SRPAR",
	"dimlist : /* empty */",
	"dimlist : dim",
	"dimlist : dimlist SCOMMA dim",
	"dim : ubound",
	"dim : expr SCOLON ubound",
	"ubound : SSTAR",
	"ubound : expr",
	"labellist : label",
	"labellist : labellist SCOMMA label",
	"label : SICON",
	"implicit : SIMPLICIT in_dcl implist",
	"implicit : implicit SCOMMA implist",
	"implist : imptype SLPAR letgroups SRPAR",
	"implist : imptype",
	"imptype : /* empty */",
	"imptype : type",
	"letgroups : letgroup",
	"letgroups : letgroups SCOMMA letgroup",
	"letgroup : letter",
	"letgroup : letter SMINUS letter",
	"letter : SNAME",
	"namelist : SNAMELIST",
	"namelist : namelist namelistentry",
	"namelistentry : SSLASH name SSLASH namelistlist",
	"namelistlist : name",
	"namelistlist : namelistlist SCOMMA name",
	"in_dcl : /* empty */",
	"funarglist : /* empty */",
	"funarglist : funargs",
	"funargs : expr",
	"funargs : funargs SCOMMA expr",
	"expr : uexpr",
	"expr : SLPAR expr SRPAR",
	"expr : complex_const",
	"uexpr : lhs",
	"uexpr : simple_const",
	"uexpr : expr addop expr",
	"uexpr : expr SSTAR expr",
	"uexpr : expr SSLASH expr",
	"uexpr : expr SPOWER expr",
	"uexpr : addop expr",
	"uexpr : expr relop expr",
	"uexpr : expr SEQV expr",
	"uexpr : expr SNEQV expr",
	"uexpr : expr SOR expr",
	"uexpr : expr SAND expr",
	"uexpr : SNOT expr",
	"uexpr : expr SCONCAT expr",
	"addop : SPLUS",
	"addop : SMINUS",
	"relop : SEQ",
	"relop : SGT",
	"relop : SLT",
	"relop : SGE",
	"relop : SLE",
	"relop : SNE",
	"lhs : name",
	"lhs : name substring",
	"lhs : name SLPAR funarglist SRPAR",
	"lhs : name SLPAR funarglist SRPAR substring",
	"substring : SLPAR opt_expr SCOLON opt_expr SRPAR",
	"opt_expr : /* empty */",
	"opt_expr : expr",
	"simple : name",
	"simple : simple_const",
	"simple_const : STRUE",
	"simple_const : SFALSE",
	"simple_const : SHOLLERITH",
	"simple_const : SICON",
	"simple_const : SRCON",
	"simple_const : SDCON",
	"simple_const : bit_const",
	"complex_const : SLPAR uexpr SCOMMA uexpr SRPAR",
	"bit_const : SHEXCON",
	"bit_const : SOCTCON",
	"bit_const : SBITCON",
	"fexpr : unpar_fexpr",
	"fexpr : SLPAR fexpr SRPAR",
	"unpar_fexpr : lhs",
	"unpar_fexpr : simple_const",
	"unpar_fexpr : fexpr addop fexpr",
	"unpar_fexpr : fexpr SSTAR fexpr",
	"unpar_fexpr : fexpr SSLASH fexpr",
	"unpar_fexpr : fexpr SPOWER fexpr",
	"unpar_fexpr : addop fexpr",
	"unpar_fexpr : fexpr SCONCAT fexpr",
	"exec : iffable",
	"exec : SDO end_spec intonlyon label intonlyoff opt_comma dospecw",
	"exec : SDO end_spec opt_comma dospecw",
	"exec : SENDDO",
	"exec : logif iffable",
	"exec : logif STHEN",
	"exec : SELSEIF end_spec SLPAR expr SRPAR STHEN",
	"exec : SELSE end_spec",
	"exec : SENDIF end_spec",
	"logif : SLOGIF end_spec SLPAR expr SRPAR",
	"dospec : name SEQUALS exprlist",
	"dospecw : dospec",
	"dospecw : SWHILE SLPAR expr SRPAR",
	"iffable : let lhs SEQUALS expr",
	"iffable : SASSIGN end_spec assignlabel STO name",
	"iffable : SCONTINUE end_spec",
	"iffable : goto",
	"iffable : io",
	"iffable : SARITHIF end_spec SLPAR expr SRPAR label SCOMMA label SCOMMA label",
	"iffable : call",
	"iffable : call SLPAR SRPAR",
	"iffable : call SLPAR callarglist SRPAR",
	"iffable : SRETURN end_spec opt_expr",
	"iffable : stop end_spec opt_expr",
	"assignlabel : SICON",
	"let : SLET",
	"goto : SGOTO end_spec label",
	"goto : SASGOTO end_spec name",
	"goto : SASGOTO end_spec name opt_comma SLPAR labellist SRPAR",
	"goto : SCOMPGOTO end_spec SLPAR labellist SRPAR opt_comma expr",
	"opt_comma : /* empty */",
	"opt_comma : SCOMMA",
	"call : SCALL end_spec name",
	"callarglist : callarg",
	"callarglist : callarglist SCOMMA callarg",
	"callarg : expr",
	"callarg : SSTAR label",
	"stop : SPAUSE",
	"stop : SSTOP",
	"exprlist : expr",
	"exprlist : exprlist SCOMMA expr",
	"end_spec : /* empty */",
	"intonlyon : /* empty */",
	"intonlyoff : /* empty */",
	"io : io1",
	"io1 : iofmove ioctl",
	"io1 : iofmove unpar_fexpr",
	"io1 : iofmove SSTAR",
	"io1 : iofmove SPOWER",
	"io1 : iofctl ioctl",
	"io1 : read ioctl",
	"io1 : read infmt",
	"io1 : read ioctl inlist",
	"io1 : read infmt SCOMMA inlist",
	"io1 : read ioctl SCOMMA inlist",
	"io1 : write ioctl",
	"io1 : write ioctl outlist",
	"io1 : print",
	"io1 : print SCOMMA outlist",
	"iofmove : fmkwd end_spec in_ioctl",
	"fmkwd : SBACKSPACE",
	"fmkwd : SREWIND",
	"fmkwd : SENDFILE",
	"iofctl : ctlkwd end_spec in_ioctl",
	"ctlkwd : SINQUIRE",
	"ctlkwd : SOPEN",
	"ctlkwd : SCLOSE",
	"infmt : unpar_fexpr",
	"infmt : SSTAR",
	"ioctl : SLPAR fexpr SRPAR",
	"ioctl : SLPAR ctllist SRPAR",
	"ctllist : ioclause",
	"ctllist : ctllist SCOMMA ioclause",
	"ioclause : fexpr",
	"ioclause : SSTAR",
	"ioclause : SPOWER",
	"ioclause : nameeq expr",
	"ioclause : nameeq SSTAR",
	"ioclause : nameeq SPOWER",
	"nameeq : SNAMEEQ",
	"read : SREAD end_spec in_ioctl",
	"write : SWRITE end_spec in_ioctl",
	"print : SPRINT end_spec fexpr in_ioctl",
	"print : SPRINT end_spec SSTAR in_ioctl",
	"inlist : inelt",
	"inlist : inlist SCOMMA inelt",
	"inelt : lhs",
	"inelt : SLPAR inlist SCOMMA dospec SRPAR",
	"outlist : uexpr",
	"outlist : other",
	"outlist : out2",
	"out2 : uexpr SCOMMA uexpr",
	"out2 : uexpr SCOMMA other",
	"out2 : other SCOMMA uexpr",
	"out2 : other SCOMMA other",
	"out2 : out2 SCOMMA uexpr",
	"out2 : out2 SCOMMA other",
	"other : complex_const",
	"other : SLPAR expr SRPAR",
	"other : SLPAR uexpr SCOMMA dospec SRPAR",
	"other : SLPAR other SCOMMA dospec SRPAR",
	"other : SLPAR out2 SCOMMA dospec SRPAR",
	"in_ioctl : /* empty */",
};
#endif /* YYDEBUG */
/* 
 *	Copyright 1987 Silicon Graphics, Inc. - All Rights Reserved
 */

/* #ident	"@(#)yacc:yaccpar	1.10" */
#ident	"$Revision$"

/*
** Skeleton parser driver for yacc output
*/
#include "stddef.h"

/*
** yacc user known macros and defines
*/
#define YYERROR		goto yyerrlab
#define YYACCEPT	return(0)
#define YYABORT		return(1)
#ifdef __cplusplus
#define YYBACKUP( newtoken, newvalue )\
{\
	if ( yychar >= 0 || ( yyr2[ yytmp ] >> 1 ) != 1 )\
	{\
		yyerror( gettxt("uxlibc:78", "syntax error - cannot backup") );\
		goto yyerrlab;\
	}\
	yychar = newtoken;\
	yystate = *yyps;\
	yylval = newvalue;\
	goto yynewstate;\
}
#else
#define YYBACKUP( newtoken, newvalue )\
{\
	if ( yychar >= 0 || ( yyr2[ yytmp ] >> 1 ) != 1 )\
	{\
		yyerror( gettxt("uxlibc:78", "Syntax error - cannot backup") );\
		goto yyerrlab;\
	}\
	yychar = newtoken;\
	yystate = *yyps;\
	yylval = newvalue;\
	goto yynewstate;\
}
#endif
#define YYRECOVERING()	(!!yyerrflag)
#define YYNEW(type)	malloc(sizeof(type) * yynewmax)
#define YYCOPY(to, from, type) \
	(type *) memcpy(to, (char *) from, yynewmax * sizeof(type))
#define YYENLARGE( from, type) \
	(type *) realloc((char *) from, yynewmax * sizeof(type))
#ifndef YYDEBUG
#	define YYDEBUG	1	/* make debugging available */
#endif

/*
** user known globals
*/
int yydebug;			/* set to 1 to get debugging */

/*
** driver internal defines
*/
#define YYFLAG		(-10000000)

/*
** global variables used by the parser
*/
YYSTYPE *yypv;			/* top of value stack */
int *yyps;			/* top of state stack */

int yystate;			/* current state */
int yytmp;			/* extra var (lasts between blocks) */

int yynerrs;			/* number of errors */
int yyerrflag;			/* error recovery flag */
int yychar;			/* current input token number */



/*
** yyparse - return 0 if worked, 1 if syntax error not recovered from
*/
#if defined(__STDC__) || defined(__cplusplus)
int yyparse(void)
#else
int yyparse()
#endif
{
	register YYSTYPE *yypvt;	/* top of value stack for $vars */

	/*
	** Initialize externals - yyparse may be called more than once
	*/
	yypv = &yyv[-1];
	yyps = &yys[-1];
	yystate = 0;
	yytmp = 0;
	yynerrs = 0;
	yyerrflag = 0;
	yychar = -1;

#if YYMAXDEPTH <= 0
	if (yymaxdepth <= 0)
	{
		if ((yymaxdepth = YYEXPAND(0)) <= 0)
		{
#ifdef __cplusplus
			yyerror(gettxt("uxlibc:79", "yacc initialization error"));
#else
			yyerror(gettxt("uxlibc:79", "Yacc initialization error"));
#endif
			YYABORT;
		}
	}
#endif

	goto yystack;
	{
		register YYSTYPE *yy_pv;	/* top of value stack */
		register int *yy_ps;		/* top of state stack */
		register int yy_state;		/* current state */
		register int  yy_n;		/* internal state number info */

		/*
		** get globals into registers.
		** branch to here only if YYBACKUP was called.
		*/
	yynewstate:
		yy_pv = yypv;
		yy_ps = yyps;
		yy_state = yystate;
		goto yy_newstate;

		/*
		** get globals into registers.
		** either we just started, or we just finished a reduction
		*/
	yystack:
		yy_pv = yypv;
		yy_ps = yyps;
		yy_state = yystate;

		/*
		** top of for (;;) loop while no reductions done
		*/
	yy_stack:
		/*
		** put a state and value onto the stacks
		*/
#if YYDEBUG
		/*
		** if debugging, look up token value in list of value vs.
		** name pairs.  0 and negative (-1) are special values.
		** Note: linear search is used since time is not a real
		** consideration while debugging.
		*/
		if ( yydebug )
		{
			register int yy_i;

			printf( "State %d, token ", yy_state );
			if ( yychar == 0 )
				printf( "end-of-file\n" );
			else if ( yychar < 0 )
				printf( "-none-\n" );
			else
			{
				for ( yy_i = 0; yytoks[yy_i].t_val >= 0;
					yy_i++ )
				{
					if ( yytoks[yy_i].t_val == yychar )
						break;
				}
				printf( "%s\n", yytoks[yy_i].t_name );
			}
		}
#endif /* YYDEBUG */
		if ( ++yy_ps >= &yys[ yymaxdepth ] )	/* room on stack? */
		{
			int yynewmax;
			ptrdiff_t yys_off;

			/* The following pointer-differences are safe, since
			 * yypvt, yy_pv, and yypv all are a multiple of
			 * sizeof(YYSTYPE) bytes from yyv.
			 */
			ptrdiff_t yypvt_off = yypvt - yyv;
			ptrdiff_t yy_pv_off = yy_pv - yyv;
			ptrdiff_t yypv_off = yypv - yyv;

			int *yys_base = yys;
#ifdef YYEXPAND
			yynewmax = YYEXPAND(yymaxdepth);
#else
			yynewmax = 2 * yymaxdepth;	/* double table size */
			if (yymaxdepth == YYMAXDEPTH)	/* first time growth */
			{
				void *newyys = YYNEW(int);
				void *newyyv = YYNEW(YYSTYPE);
				if (newyys != 0 && newyyv != 0)
				{
					yys = YYCOPY(newyys, yys, int);
					yyv = YYCOPY(newyyv, yyv, YYSTYPE);
				}
				else
					yynewmax = 0;	/* failed */
			}
			else				/* not first time */
			{
				yys = YYENLARGE(yys, int);
				yyv = YYENLARGE(yyv, YYSTYPE);
				if (yys == 0 || yyv == 0)
					yynewmax = 0;	/* failed */
			}
#endif
			if (yynewmax <= yymaxdepth)	/* tables not expanded */
			{
#ifdef __cplusplus
				yyerror( gettxt("uxlibc:80", "yacc stack overflow") );
#else
				yyerror( gettxt("uxlibc:80", "Yacc stack overflow") );
#endif
				YYABORT;
			}
			yymaxdepth = yynewmax;

			/* reset pointers into yys */
			yys_off = yys - yys_base;
			yy_ps = yy_ps + yys_off;
			yyps = yyps + yys_off;

			/* reset pointers into yyv */
			yypvt = yyv + yypvt_off;
			yy_pv = yyv + yy_pv_off;
			yypv = yyv + yypv_off;
		}
		*yy_ps = yy_state;
		*++yy_pv = yyval;

		/*
		** we have a new state - find out what to do
		*/
	yy_newstate:
		if ( ( yy_n = yypact[ yy_state ] ) <= YYFLAG )
			goto yydefault;		/* simple state */
#if YYDEBUG
		/*
		** if debugging, need to mark whether new token grabbed
		*/
		yytmp = yychar < 0;
#endif
		if ( ( yychar < 0 ) && ( ( yychar = yylex() ) < 0 ) )
			yychar = 0;		/* reached EOF */
#if YYDEBUG
		if ( yydebug && yytmp )
		{
			register int yy_i;

			printf( "Received token " );
			if ( yychar == 0 )
				printf( "end-of-file\n" );
			else if ( yychar < 0 )
				printf( "-none-\n" );
			else
			{
				for ( yy_i = 0; yytoks[yy_i].t_val >= 0;
					yy_i++ )
				{
					if ( yytoks[yy_i].t_val == yychar )
						break;
				}
				printf( "%s\n", yytoks[yy_i].t_name );
			}
		}
#endif /* YYDEBUG */
		if ( ( ( yy_n += yychar ) < 0 ) || ( yy_n >= YYLAST ) )
			goto yydefault;
		if ( yychk[ yy_n = yyact[ yy_n ] ] == yychar )	/*valid shift*/
		{
			yychar = -1;
			yyval = yylval;
			yy_state = yy_n;
			if ( yyerrflag > 0 )
				yyerrflag--;
			goto yy_stack;
		}

	yydefault:
		if ( ( yy_n = yydef[ yy_state ] ) == -2 )
		{
#if YYDEBUG
			yytmp = yychar < 0;
#endif
			if ( ( yychar < 0 ) && ( ( yychar = yylex() ) < 0 ) )
				yychar = 0;		/* reached EOF */
#if YYDEBUG
			if ( yydebug && yytmp )
			{
				register int yy_i;

				printf( "Received token " );
				if ( yychar == 0 )
					printf( "end-of-file\n" );
				else if ( yychar < 0 )
					printf( "-none-\n" );
				else
				{
					for ( yy_i = 0;
						yytoks[yy_i].t_val >= 0;
						yy_i++ )
					{
						if ( yytoks[yy_i].t_val
							== yychar )
						{
							break;
						}
					}
					printf( "%s\n", yytoks[yy_i].t_name );
				}
			}
#endif /* YYDEBUG */
			/*
			** look through exception table
			*/
			{
				register int *yyxi = yyexca;

				while ( ( *yyxi != -1 ) ||
					( yyxi[1] != yy_state ) )
				{
					yyxi += 2;
				}
				while ( ( *(yyxi += 2) >= 0 ) &&
					( *yyxi != yychar ) )
					;
				if ( ( yy_n = yyxi[1] ) < 0 )
					YYACCEPT;
			}
		}

		/*
		** check for syntax error
		*/
		if ( yy_n == 0 )	/* have an error */
		{
			/* no worry about speed here! */
			switch ( yyerrflag )
			{
			case 0:		/* new error */
#ifdef __cplusplus
				yyerror( gettxt("uxlibc:81", "syntax error") );
#else
				yyerror( gettxt("uxlibc:81", "Syntax error") );
#endif
				goto skip_init;
			yyerrlab:
				/*
				** get globals into registers.
				** we have a user generated syntax type error
				*/
				yy_pv = yypv;
				yy_ps = yyps;
				yy_state = yystate;
				yynerrs++;
				/* FALLTHRU */
			skip_init:
			case 1:
			case 2:		/* incompletely recovered error */
					/* try again... */
				yyerrflag = 3;
				/*
				** find state where "error" is a legal
				** shift action
				*/
				while ( yy_ps >= yys )
				{
					yy_n = yypact[ *yy_ps ] + YYERRCODE;
					if ( yy_n >= 0 && yy_n < YYLAST &&
						yychk[yyact[yy_n]] == YYERRCODE)					{
						/*
						** simulate shift of "error"
						*/
						yy_state = yyact[ yy_n ];
						goto yy_stack;
					}
					/*
					** current state has no shift on
					** "error", pop stack
					*/
#if YYDEBUG
#	define _POP_ "Error recovery pops state %d, uncovers state %d\n"
					if ( yydebug )
						printf( _POP_, *yy_ps,
							yy_ps[-1] );
#	undef _POP_
#endif
					yy_ps--;
					yy_pv--;
				}
				/*
				** there is no state on stack with "error" as
				** a valid shift.  give up.
				*/
				YYABORT;
			case 3:		/* no shift yet; eat a token */
#if YYDEBUG
				/*
				** if debugging, look up token in list of
				** pairs.  0 and negative shouldn't occur,
				** but since timing doesn't matter when
				** debugging, it doesn't hurt to leave the
				** tests here.
				*/
				if ( yydebug )
				{
					register int yy_i;

					printf( "Error recovery discards " );
					if ( yychar == 0 )
						printf( "token end-of-file\n" );
					else if ( yychar < 0 )
						printf( "token -none-\n" );
					else
					{
						for ( yy_i = 0;
							yytoks[yy_i].t_val >= 0;
							yy_i++ )
						{
							if ( yytoks[yy_i].t_val
								== yychar )
							{
								break;
							}
						}
						printf( "token %s\n",
							yytoks[yy_i].t_name );
					}
				}
#endif /* YYDEBUG */
				if ( yychar == 0 )	/* reached EOF. quit */
					YYABORT;
				yychar = -1;
				goto yy_newstate;
			}
		}/* end if ( yy_n == 0 ) */
		/*
		** reduction by production yy_n
		** put stack tops, etc. so things right after switch
		*/
#if YYDEBUG
		/*
		** if debugging, print the string that is the user's
		** specification of the reduction which is just about
		** to be done.
		*/
		if ( yydebug )
			printf( "Reduce by (%d) \"%s\"\n",
				yy_n, yyreds[ yy_n ] );
#endif
		yytmp = yy_n;			/* value to switch over */
		yypvt = yy_pv;			/* $vars top of value stack */
		/*
		** Look in goto table for next state
		** Sorry about using yy_state here as temporary
		** register variable, but why not, if it works...
		** If yyr2[ yy_n ] doesn't have the low order bit
		** set, then there is no action to be done for
		** this reduction.  So, no saving & unsaving of
		** registers done.  The only difference between the
		** code just after the if and the body of the if is
		** the goto yy_stack in the body.  This way the test
		** can be made before the choice of what to do is needed.
		*/
		{
			/* length of production doubled with extra bit */
			register int yy_len = yyr2[ yy_n ];

			if ( !( yy_len & 01 ) )
			{
				yy_len >>= 1;
				yyval = ( yy_pv -= yy_len )[1];	/* $$ = $1 */
				yy_state = yypgo[ yy_n = yyr1[ yy_n ] ] +
					*( yy_ps -= yy_len ) + 1;
				if ( yy_state >= YYLAST ||
					yychk[ yy_state =
					yyact[ yy_state ] ] != -yy_n )
				{
					yy_state = yyact[ yypgo[ yy_n ] ];
				}
				goto yy_stack;
			}
			yy_len >>= 1;
			yyval = ( yy_pv -= yy_len )[1];	/* $$ = $1 */
			yy_state = yypgo[ yy_n = yyr1[ yy_n ] ] +
				*( yy_ps -= yy_len ) + 1;
			if ( yy_state >= YYLAST ||
				yychk[ yy_state = yyact[ yy_state ] ] != -yy_n )
			{
				yy_state = yyact[ yypgo[ yy_n ] ];
			}
		}
					/* save until reenter driver code */
		yystate = yy_state;
		yyps = yy_ps;
		yypv = yy_pv;
	}
	/*
	** code supplied by user is placed in this switch
	*/
	switch( yytmp )
	{
		
case 3:
/* # line 219 "gram.in" */
{
/* stat:   is the nonterminal for Fortran statements */

		  lastwasbranch = NO; } break;
case 5:
/* # line 225 "gram.in" */
{ /* forbid further statement function definitions... */
		  if (parstate == INDATA && laststfcn != thisstno)
			parstate = INEXEC;
		  thisstno++;
		  if(yypvt[-1].labval && (yypvt[-1].labval->labelno==dorange))
			enddo(yypvt[-1].labval->labelno);
		  if(lastwasbranch && thislabel==NULL)
			warn("statement cannot be reached");
		  lastwasbranch = thiswasbranch;
		  thiswasbranch = NO;
		  if(yypvt[-1].labval)
			{
			if(yypvt[-1].labval->labtype == LABFORMAT)
				err("label already that of a format");
			else
				yypvt[-1].labval->labtype = LABEXEC;
			}
		  freetemps();
		} break;
case 6:
/* # line 245 "gram.in" */
{ if (can_include)
			doinclude( yypvt[-0].charpval );
		  else {
			fprintf(diagfile, "Cannot open file %s\n", yypvt[-0].charpval);
			done(1);
			}
		} break;
case 7:
/* # line 253 "gram.in" */
{ if (yypvt[-2].labval)
			lastwasbranch = NO;
		  endproc(); /* lastwasbranch = NO; -- set in endproc() */
		} break;
case 8:
/* # line 258 "gram.in" */
{ unclassifiable();

/* flline flushes the current line, ignoring the rest of the text there */

		  flline(); } break;
case 9:
/* # line 264 "gram.in" */
{ flline();  needkwd = NO;  inioctl = NO;
		  yyerrok; yyclearin; } break;
case 10:
/* # line 269 "gram.in" */
{
		if(yystno != 0)
			{
			yyval.labval = thislabel =  mklabel(yystno);
			if( ! headerdone ) {
				if (procclass == CLUNKNOWN)
					procclass = CLMAIN;
				puthead(CNULL, procclass);
				}
			if(thislabel->labdefined)
				execerr("label %s already defined",
					convic(thislabel->stateno) );
			else	{
				if(thislabel->blklevel!=0 && thislabel->blklevel<blklevel
				    && thislabel->labtype!=LABFORMAT)
					warn1("there is a branch to label %s from outside block",
					      convic( (ftnint) (thislabel->stateno) ) );
				thislabel->blklevel = blklevel;
				thislabel->labdefined = YES;
				if(thislabel->labtype != LABFORMAT)
					p1_label((long)(thislabel - labeltab));
				}
			}
		else    yyval.labval = thislabel = NULL;
		} break;
case 11:
/* # line 297 "gram.in" */
{startproc(yypvt[-0].extval, CLMAIN); } break;
case 12:
/* # line 299 "gram.in" */
{	warn("ignoring arguments to main program");
			/* hashclear(); */
			startproc(yypvt[-1].extval, CLMAIN); } break;
case 13:
/* # line 303 "gram.in" */
{ if(yypvt[-0].extval) NO66("named BLOCKDATA");
		  startproc(yypvt[-0].extval, CLBLOCK); } break;
case 14:
/* # line 306 "gram.in" */
{ entrypt(CLPROC, TYSUBR, (ftnint) 0,  yypvt[-1].extval, yypvt[-0].chval); } break;
case 15:
/* # line 308 "gram.in" */
{ entrypt(CLPROC, TYUNKNOWN, (ftnint) 0, yypvt[-1].extval, yypvt[-0].chval); } break;
case 16:
/* # line 310 "gram.in" */
{ entrypt(CLPROC, yypvt[-4].ival, varleng, yypvt[-1].extval, yypvt[-0].chval); } break;
case 17:
/* # line 312 "gram.in" */
{ if(parstate==OUTSIDE || procclass==CLMAIN
			|| procclass==CLBLOCK)
				execerr("misplaced entry statement", CNULL);
		  entrypt(CLENTRY, 0, (ftnint) 0, yypvt[-1].extval, yypvt[-0].chval);
		} break;
case 18:
/* # line 320 "gram.in" */
{ newproc(); } break;
case 19:
/* # line 324 "gram.in" */
{ yyval.extval = newentry(yypvt[-0].namval, 1); } break;
case 20:
/* # line 328 "gram.in" */
{ yyval.namval = mkname(token); } break;
case 21:
/* # line 331 "gram.in" */
{ yyval.extval = NULL; } break;
case 29:
/* # line 349 "gram.in" */
{ yyval.chval = 0; } break;
case 30:
/* # line 351 "gram.in" */
{ NO66(" () argument list");
		  yyval.chval = 0; } break;
case 31:
/* # line 354 "gram.in" */
{yyval.chval = yypvt[-1].chval; } break;
case 32:
/* # line 358 "gram.in" */
{ yyval.chval = (yypvt[-0].namval ? mkchain((char *)yypvt[-0].namval,CHNULL) : CHNULL ); } break;
case 33:
/* # line 360 "gram.in" */
{ if(yypvt[-0].namval) yypvt[-2].chval = yyval.chval = mkchain((char *)yypvt[-0].namval, yypvt[-2].chval); } break;
case 34:
/* # line 364 "gram.in" */
{ if(yypvt[-0].namval->vstg!=STGUNKNOWN && yypvt[-0].namval->vstg!=STGARG)
			dclerr("name declared as argument after use", yypvt[-0].namval);
		  yypvt[-0].namval->vstg = STGARG;
		} break;
case 35:
/* # line 369 "gram.in" */
{ NO66("altenate return argument");

/* substars   means that '*'ed formal parameters should be replaced.
   This is used to specify alternate return labels; in theory, only
   parameter slots which have '*' should accept the statement labels.
   This compiler chooses to ignore the '*'s in the formal declaration, and
   always return the proper value anyway.

   This variable is only referred to in   proc.c   */

		  yyval.namval = 0;  substars = YES; } break;
case 36:
/* # line 385 "gram.in" */
{
		char *s;
		s = copyn(toklen+1, token);
		s[toklen] = '\0';
		yyval.charpval = s;
		} break;
case 45:
/* # line 401 "gram.in" */
{ NO66("SAVE statement");
		  saveall = YES; } break;
case 46:
/* # line 404 "gram.in" */
{ NO66("SAVE statement"); } break;
case 47:
/* # line 406 "gram.in" */
{ fmtstmt(thislabel); setfmt(thislabel); } break;
case 48:
/* # line 408 "gram.in" */
{ NO66("PARAMETER statement"); } break;
case 49:
/* # line 412 "gram.in" */
{ settype(yypvt[-4].namval, yypvt[-6].ival, yypvt[-0].lval);
		  if(ndim>0) setbound(yypvt[-4].namval,ndim,dims);
		} break;
case 50:
/* # line 416 "gram.in" */
{ settype(yypvt[-2].namval, yypvt[-4].ival, yypvt[-0].lval);
		  if(ndim>0) setbound(yypvt[-2].namval,ndim,dims);
		} break;
case 51:
/* # line 420 "gram.in" */
{ if (new_dcl == 2) {
			err("attempt to give DATA in type-declaration");
			new_dcl = 1;
			}
		} break;
case 52:
/* # line 427 "gram.in" */
{ new_dcl = 2; } break;
case 53:
/* # line 430 "gram.in" */
{ varleng = yypvt[-0].lval; } break;
case 54:
/* # line 434 "gram.in" */
{ varleng = (yypvt[-0].ival<0 || ONEOF(yypvt[-0].ival,M(TYLOGICAL)|M(TYLONG))
				? 0 : typesize[yypvt[-0].ival]);
		  vartype = yypvt[-0].ival; } break;
case 55:
/* # line 439 "gram.in" */
{ yyval.ival = TYLONG; } break;
case 56:
/* # line 440 "gram.in" */
{ yyval.ival = tyreal; } break;
case 57:
/* # line 441 "gram.in" */
{ ++complex_seen; yyval.ival = tycomplex; } break;
case 58:
/* # line 442 "gram.in" */
{ yyval.ival = TYDREAL; } break;
case 59:
/* # line 443 "gram.in" */
{ ++dcomplex_seen; NOEXT("DOUBLE COMPLEX statement"); yyval.ival = TYDCOMPLEX; } break;
case 60:
/* # line 444 "gram.in" */
{ yyval.ival = TYLOGICAL; } break;
case 61:
/* # line 445 "gram.in" */
{ NO66("CHARACTER statement"); yyval.ival = TYCHAR; } break;
case 62:
/* # line 446 "gram.in" */
{ yyval.ival = TYUNKNOWN; } break;
case 63:
/* # line 447 "gram.in" */
{ yyval.ival = TYUNKNOWN; } break;
case 64:
/* # line 448 "gram.in" */
{ NOEXT("AUTOMATIC statement"); yyval.ival = - STGAUTO; } break;
case 65:
/* # line 449 "gram.in" */
{ NOEXT("STATIC statement"); yyval.ival = - STGBSS; } break;
case 66:
/* # line 450 "gram.in" */
{ yyval.ival = TYINT1; } break;
case 67:
/* # line 454 "gram.in" */
{ yyval.lval = varleng; } break;
case 68:
/* # line 456 "gram.in" */
{
		expptr p;
		p = yypvt[-1].expval;
		NO66("length specification *n");
		if( ! ISICON(p) || p->constblock.Const.ci <= 0 )
			{
			yyval.lval = 0;
			dclerr("length must be a positive integer constant",
				NPNULL);
			}
		else {
			if (vartype == TYCHAR)
				yyval.lval = p->constblock.Const.ci;
			else switch((int)p->constblock.Const.ci) {
				case 1:	yyval.lval = 1; break;
				case 2: yyval.lval = typesize[TYSHORT];	break;
				case 4: yyval.lval = typesize[TYLONG];	break;
				case 8: yyval.lval = typesize[TYDREAL];	break;
				case 16: yyval.lval = typesize[TYDCOMPLEX]; break;
				default:
					dclerr("invalid length",NPNULL);
					yyval.lval = varleng;
				}
			}
		} break;
case 69:
/* # line 482 "gram.in" */
{ NO66("length specification *(*)"); yyval.lval = -1; } break;
case 70:
/* # line 486 "gram.in" */
{ incomm( yyval.extval = comblock("") , yypvt[-0].namval ); } break;
case 71:
/* # line 488 "gram.in" */
{ yyval.extval = yypvt[-1].extval;  incomm(yypvt[-1].extval, yypvt[-0].namval); } break;
case 72:
/* # line 490 "gram.in" */
{ yyval.extval = yypvt[-2].extval;  incomm(yypvt[-2].extval, yypvt[-0].namval); } break;
case 73:
/* # line 492 "gram.in" */
{ incomm(yypvt[-2].extval, yypvt[-0].namval); } break;
case 74:
/* # line 496 "gram.in" */
{ yyval.extval = comblock(""); } break;
case 75:
/* # line 498 "gram.in" */
{ yyval.extval = comblock(token); } break;
case 76:
/* # line 502 "gram.in" */
{ setext(yypvt[-0].namval); } break;
case 77:
/* # line 504 "gram.in" */
{ setext(yypvt[-0].namval); } break;
case 78:
/* # line 508 "gram.in" */
{ NO66("INTRINSIC statement"); setintr(yypvt[-0].namval); } break;
case 79:
/* # line 510 "gram.in" */
{ setintr(yypvt[-0].namval); } break;
case 82:
/* # line 518 "gram.in" */
{
		struct Equivblock *p;
		if(nequiv >= maxequiv)
			many("equivalences", 'q', maxequiv);
		p  =  & eqvclass[nequiv++];
		p->eqvinit = NO;
		p->eqvbottom = 0;
		p->eqvtop = 0;
		p->equivs = yypvt[-1].eqvval;
		} break;
case 83:
/* # line 531 "gram.in" */
{ yyval.eqvval=ALLOC(Eqvchain);
		  yyval.eqvval->eqvitem.eqvlhs = primchk(yypvt[-0].expval);
		} break;
case 84:
/* # line 535 "gram.in" */
{ yyval.eqvval=ALLOC(Eqvchain);
		  yyval.eqvval->eqvitem.eqvlhs = primchk(yypvt[-0].expval);
		  yyval.eqvval->eqvnextp = yypvt[-2].eqvval;
		} break;
case 87:
/* # line 546 "gram.in" */
{ if(parstate == OUTSIDE)
			{
			newproc();
			startproc(ESNULL, CLMAIN);
			}
		  if(parstate < INDATA)
			{
			enddcl();
			parstate = INDATA;
			datagripe = 1;
			}
		} break;
case 88:
/* # line 561 "gram.in" */
{ ftnint junk;
		  if(nextdata(&junk) != NULL)
			err("too few initializers");
		  frdata(yypvt[-4].chval);
		  frrpl();
		} break;
case 89:
/* # line 569 "gram.in" */
{ frchain(&datastack); curdtp = 0; } break;
case 90:
/* # line 571 "gram.in" */
{ pop_datastack(); } break;
case 91:
/* # line 573 "gram.in" */
{ toomanyinit = NO; } break;
case 94:
/* # line 578 "gram.in" */
{ dataval(ENULL, yypvt[-0].expval); } break;
case 95:
/* # line 580 "gram.in" */
{ dataval(yypvt[-2].expval, yypvt[-0].expval); } break;
case 97:
/* # line 585 "gram.in" */
{ if( yypvt[-1].ival==OPMINUS && ISCONST(yypvt[-0].expval) )
			consnegop((Constp)yypvt[-0].expval);
		  yyval.expval = yypvt[-0].expval;
		} break;
case 101:
/* # line 597 "gram.in" */
{ int k;
		  yypvt[-0].namval->vsave = YES;
		  k = yypvt[-0].namval->vstg;
		if( ! ONEOF(k, M(STGUNKNOWN)|M(STGBSS)|M(STGINIT)) )
			dclerr("can only save static variables", yypvt[-0].namval);
		} break;
case 105:
/* # line 611 "gram.in" */
{ if(yypvt[-2].namval->vclass == CLUNKNOWN)
			make_param((struct Paramblock *)yypvt[-2].namval, yypvt[-0].expval);
		  else dclerr("cannot make into parameter", yypvt[-2].namval);
		} break;
case 106:
/* # line 618 "gram.in" */
{ if(ndim>0) setbound(yypvt[-1].namval, ndim, dims); } break;
case 107:
/* # line 622 "gram.in" */
{ Namep np;
		  struct Primblock *pp = (struct Primblock *)yypvt[-0].expval;
		  int tt = yypvt[-0].expval->tag;
		  if (tt != TPRIM) {
			if (tt == TCONST)
				err("parameter in data statement");
			else
				erri("tag %d in data statement",tt);
			yyval.chval = 0;
			err_lineno = lineno;
			break;
			}
		  np = pp -> namep;
		  vardcl(np);
		  if ((pp->fcharp || pp->lcharp)
		   && (np->vtype != TYCHAR || np->vdim))
			sserr(np);
		  if(np->vstg == STGCOMMON)
			extsymtab[np->vardesc.varno].extinit = YES;
		  else if(np->vstg==STGEQUIV)
			eqvclass[np->vardesc.varno].eqvinit = YES;
		  else if(np->vstg!=STGINIT && np->vstg!=STGBSS) {
			errstr(np->vstg == STGARG
				? "Dummy argument \"%.60s\" in data statement."
				: "Cannot give data to \"%.75s\"",
				np->fvarname);
			yyval.chval = 0;
			err_lineno = lineno;
			break;
			}
		  yyval.chval = mkchain((char *)yypvt[-0].expval, CHNULL);
		} break;
case 108:
/* # line 655 "gram.in" */
{ chainp p; struct Impldoblock *q;
		pop_datastack();
		q = ALLOC(Impldoblock);
		q->tag = TIMPLDO;
		(q->varnp = (Namep) (yypvt[-1].chval->datap))->vimpldovar = 1;
		p = yypvt[-1].chval->nextp;
		if(p)  { q->implb = (expptr)(p->datap); p = p->nextp; }
		if(p)  { q->impub = (expptr)(p->datap); p = p->nextp; }
		if(p)  { q->impstep = (expptr)(p->datap); }
		frchain( & (yypvt[-1].chval) );
		yyval.chval = mkchain((char *)q, CHNULL);
		q->datalist = hookup(yypvt[-3].chval, yyval.chval);
		} break;
case 109:
/* # line 671 "gram.in" */
{ if (!datastack)
			curdtp = 0;
		  datastack = mkchain((char *)curdtp, datastack);
		  curdtp = yypvt[-0].chval; curdtelt = 0;
		  } break;
case 110:
/* # line 677 "gram.in" */
{ yyval.chval = hookup(yypvt[-2].chval, yypvt[-0].chval); } break;
case 111:
/* # line 681 "gram.in" */
{ ndim = 0; } break;
case 113:
/* # line 685 "gram.in" */
{ ndim = 0; } break;
case 116:
/* # line 690 "gram.in" */
{
		  if(ndim == maxdim)
			err("too many dimensions");
		  else if(ndim < maxdim)
			{ dims[ndim].lb = 0;
			  dims[ndim].ub = yypvt[-0].expval;
			}
		  ++ndim;
		} break;
case 117:
/* # line 700 "gram.in" */
{
		  if(ndim == maxdim)
			err("too many dimensions");
		  else if(ndim < maxdim)
			{ dims[ndim].lb = yypvt[-2].expval;
			  dims[ndim].ub = yypvt[-0].expval;
			}
		  ++ndim;
		} break;
case 118:
/* # line 712 "gram.in" */
{ yyval.expval = 0; } break;
case 120:
/* # line 717 "gram.in" */
{ nstars = 1; labarray[0] = yypvt[-0].labval; } break;
case 121:
/* # line 719 "gram.in" */
{ if(nstars < maxlablist)  labarray[nstars++] = yypvt[-0].labval; } break;
case 122:
/* # line 723 "gram.in" */
{ yyval.labval = execlab( convci(toklen, token) ); } break;
case 123:
/* # line 727 "gram.in" */
{ NO66("IMPLICIT statement"); } break;
case 126:
/* # line 733 "gram.in" */
{ if (vartype != TYUNKNOWN)
			dclerr("-- expected letter range",NPNULL);
		  setimpl(vartype, varleng, 'a', 'z'); } break;
case 127:
/* # line 738 "gram.in" */
{ needkwd = 1; } break;
case 131:
/* # line 747 "gram.in" */
{ setimpl(vartype, varleng, yypvt[-0].ival, yypvt[-0].ival); } break;
case 132:
/* # line 749 "gram.in" */
{ setimpl(vartype, varleng, yypvt[-2].ival, yypvt[-0].ival); } break;
case 133:
/* # line 753 "gram.in" */
{ if(toklen!=1 || token[0]<'a' || token[0]>'z')
			{
			dclerr("implicit item must be single letter", NPNULL);
			yyval.ival = 0;
			}
		  else yyval.ival = token[0];
		} break;
case 136:
/* # line 767 "gram.in" */
{
		if(yypvt[-2].namval->vclass == CLUNKNOWN)
			{
			yypvt[-2].namval->vclass = CLNAMELIST;
			yypvt[-2].namval->vtype = TYINT;
			yypvt[-2].namval->vstg = STGBSS;
			yypvt[-2].namval->varxptr.namelist = yypvt[-0].chval;
			yypvt[-2].namval->vardesc.varno = ++lastvarno;
			}
		else dclerr("cannot be a namelist name", yypvt[-2].namval);
		} break;
case 137:
/* # line 781 "gram.in" */
{ yyval.chval = mkchain((char *)yypvt[-0].namval, CHNULL); } break;
case 138:
/* # line 783 "gram.in" */
{ yyval.chval = hookup(yypvt[-2].chval, mkchain((char *)yypvt[-0].namval, CHNULL)); } break;
case 139:
/* # line 787 "gram.in" */
{ switch(parstate)
			{
			case OUTSIDE:	newproc();
					startproc(ESNULL, CLMAIN);
			case INSIDE:	parstate = INDCL;
			case INDCL:	break;

			case INDATA:
				if (datagripe) {
					errstr(
				"Statement order error: declaration after DATA",
						CNULL);
					datagripe = 0;
					}
				break;

			default:
				dclerr("declaration among executables", NPNULL);
			}
		} break;
case 140:
/* # line 809 "gram.in" */
{ yyval.chval = 0; } break;
case 141:
/* # line 811 "gram.in" */
{ yyval.chval = revchain(yypvt[-0].chval); } break;
case 142:
/* # line 815 "gram.in" */
{ yyval.chval = mkchain((char *)yypvt[-0].expval, CHNULL); } break;
case 143:
/* # line 817 "gram.in" */
{ yyval.chval = mkchain((char *)yypvt[-0].expval, yypvt[-2].chval); } break;
case 145:
/* # line 822 "gram.in" */
{ yyval.expval = yypvt[-1].expval; if (yyval.expval->tag == TPRIM)
					yyval.expval->primblock.parenused = 1; } break;
case 149:
/* # line 830 "gram.in" */
{ yyval.expval = mkexpr(yypvt[-1].ival, yypvt[-2].expval, yypvt[-0].expval); } break;
case 150:
/* # line 832 "gram.in" */
{ yyval.expval = mkexpr(OPSTAR, yypvt[-2].expval, yypvt[-0].expval); } break;
case 151:
/* # line 834 "gram.in" */
{ yyval.expval = mkexpr(OPSLASH, yypvt[-2].expval, yypvt[-0].expval); } break;
case 152:
/* # line 836 "gram.in" */
{ yyval.expval = mkexpr(OPPOWER, yypvt[-2].expval, yypvt[-0].expval); } break;
case 153:
/* # line 838 "gram.in" */
{ if(yypvt[-1].ival == OPMINUS)
			yyval.expval = mkexpr(OPNEG, yypvt[-0].expval, ENULL);
		  else 	yyval.expval = yypvt[-0].expval;
		} break;
case 154:
/* # line 843 "gram.in" */
{ yyval.expval = mkexpr(yypvt[-1].ival, yypvt[-2].expval, yypvt[-0].expval); } break;
case 155:
/* # line 845 "gram.in" */
{ NO66(".EQV. operator");
		  yyval.expval = mkexpr(OPEQV, yypvt[-2].expval,yypvt[-0].expval); } break;
case 156:
/* # line 848 "gram.in" */
{ NO66(".NEQV. operator");
		  yyval.expval = mkexpr(OPNEQV, yypvt[-2].expval, yypvt[-0].expval); } break;
case 157:
/* # line 851 "gram.in" */
{ yyval.expval = mkexpr(OPOR, yypvt[-2].expval, yypvt[-0].expval); } break;
case 158:
/* # line 853 "gram.in" */
{ yyval.expval = mkexpr(OPAND, yypvt[-2].expval, yypvt[-0].expval); } break;
case 159:
/* # line 855 "gram.in" */
{ yyval.expval = mkexpr(OPNOT, yypvt[-0].expval, ENULL); } break;
case 160:
/* # line 857 "gram.in" */
{ NO66("concatenation operator //");
		  yyval.expval = mkexpr(OPCONCAT, yypvt[-2].expval, yypvt[-0].expval); } break;
case 161:
/* # line 861 "gram.in" */
{ yyval.ival = OPPLUS; } break;
case 162:
/* # line 862 "gram.in" */
{ yyval.ival = OPMINUS; } break;
case 163:
/* # line 865 "gram.in" */
{ yyval.ival = OPEQ; } break;
case 164:
/* # line 866 "gram.in" */
{ yyval.ival = OPGT; } break;
case 165:
/* # line 867 "gram.in" */
{ yyval.ival = OPLT; } break;
case 166:
/* # line 868 "gram.in" */
{ yyval.ival = OPGE; } break;
case 167:
/* # line 869 "gram.in" */
{ yyval.ival = OPLE; } break;
case 168:
/* # line 870 "gram.in" */
{ yyval.ival = OPNE; } break;
case 169:
/* # line 874 "gram.in" */
{ yyval.expval = mkprim(yypvt[-0].namval, LBNULL, CHNULL); } break;
case 170:
/* # line 876 "gram.in" */
{ NO66("substring operator :");
		  yyval.expval = mkprim(yypvt[-1].namval, LBNULL, yypvt[-0].chval); } break;
case 171:
/* # line 879 "gram.in" */
{ yyval.expval = mkprim(yypvt[-3].namval, mklist(yypvt[-1].chval), CHNULL); } break;
case 172:
/* # line 881 "gram.in" */
{ NO66("substring operator :");
		  yyval.expval = mkprim(yypvt[-4].namval, mklist(yypvt[-2].chval), yypvt[-0].chval); } break;
case 173:
/* # line 886 "gram.in" */
{ yyval.chval = mkchain((char *)yypvt[-3].expval, mkchain((char *)yypvt[-1].expval,CHNULL)); } break;
case 174:
/* # line 890 "gram.in" */
{ yyval.expval = 0; } break;
case 176:
/* # line 895 "gram.in" */
{ if(yypvt[-0].namval->vclass == CLPARAM)
			yyval.expval = (expptr) cpexpr(
				( (struct Paramblock *) (yypvt[-0].namval) ) -> paramval);
		} break;
case 178:
/* # line 902 "gram.in" */
{ yyval.expval = mklogcon(1); } break;
case 179:
/* # line 903 "gram.in" */
{ yyval.expval = mklogcon(0); } break;
case 180:
/* # line 904 "gram.in" */
{ yyval.expval = mkstrcon(toklen, token); } break;
case 181:
/* # line 905 "gram.in" */
 { yyval.expval = mkintcon( convci(toklen, token) ); } break;
case 182:
/* # line 906 "gram.in" */
 { yyval.expval = mkrealcon(tyreal, token); } break;
case 183:
/* # line 907 "gram.in" */
 { yyval.expval = mkrealcon(TYDREAL, token); } break;
case 185:
/* # line 912 "gram.in" */
{ yyval.expval = mkcxcon(yypvt[-3].expval,yypvt[-1].expval); } break;
case 186:
/* # line 916 "gram.in" */
{ NOEXT("hex constant");
		  yyval.expval = mkbitcon(4, toklen, token); } break;
case 187:
/* # line 919 "gram.in" */
{ NOEXT("octal constant");
		  yyval.expval = mkbitcon(3, toklen, token); } break;
case 188:
/* # line 922 "gram.in" */
{ NOEXT("binary constant");
		  yyval.expval = mkbitcon(1, toklen, token); } break;
case 190:
/* # line 928 "gram.in" */
{ yyval.expval = yypvt[-1].expval; } break;
case 193:
/* # line 934 "gram.in" */
{ yyval.expval = mkexpr(yypvt[-1].ival, yypvt[-2].expval, yypvt[-0].expval); } break;
case 194:
/* # line 936 "gram.in" */
{ yyval.expval = mkexpr(OPSTAR, yypvt[-2].expval, yypvt[-0].expval); } break;
case 195:
/* # line 938 "gram.in" */
{ yyval.expval = mkexpr(OPSLASH, yypvt[-2].expval, yypvt[-0].expval); } break;
case 196:
/* # line 940 "gram.in" */
{ yyval.expval = mkexpr(OPPOWER, yypvt[-2].expval, yypvt[-0].expval); } break;
case 197:
/* # line 942 "gram.in" */
{ if(yypvt[-1].ival == OPMINUS)
			yyval.expval = mkexpr(OPNEG, yypvt[-0].expval, ENULL);
		  else	yyval.expval = yypvt[-0].expval;
		} break;
case 198:
/* # line 947 "gram.in" */
{ NO66("concatenation operator //");
		  yyval.expval = mkexpr(OPCONCAT, yypvt[-2].expval, yypvt[-0].expval); } break;
case 200:
/* # line 952 "gram.in" */
{
		if(yypvt[-3].labval->labdefined)
			execerr("no backward DO loops", CNULL);
		yypvt[-3].labval->blklevel = blklevel+1;
		exdo(yypvt[-3].labval->labelno, NPNULL, yypvt[-0].chval);
		} break;
case 201:
/* # line 959 "gram.in" */
{
		exdo((int)(ctls - ctlstack - 2), NPNULL, yypvt[-0].chval);
		NOEXT("DO without label");
		} break;
case 202:
/* # line 964 "gram.in" */
{ exenddo(NPNULL); } break;
case 203:
/* # line 966 "gram.in" */
{ exendif();  thiswasbranch = NO; } break;
case 205:
/* # line 969 "gram.in" */
{ exelif(yypvt[-2].expval); lastwasbranch = NO; } break;
case 206:
/* # line 971 "gram.in" */
{ exelse(); lastwasbranch = NO; } break;
case 207:
/* # line 973 "gram.in" */
{ exendif(); lastwasbranch = NO; } break;
case 208:
/* # line 977 "gram.in" */
{ exif(yypvt[-1].expval); } break;
case 209:
/* # line 981 "gram.in" */
{ yyval.chval = mkchain((char *)yypvt[-2].namval, yypvt[-0].chval); } break;
case 211:
/* # line 986 "gram.in" */
{ yyval.chval = mkchain(CNULL, (chainp)yypvt[-1].expval); } break;
case 212:
/* # line 990 "gram.in" */
{ exequals((struct Primblock *)yypvt[-2].expval, yypvt[-0].expval); } break;
case 213:
/* # line 992 "gram.in" */
{ exassign(yypvt[-0].namval, yypvt[-2].labval); } break;
case 216:
/* # line 996 "gram.in" */
{ inioctl = NO; } break;
case 217:
/* # line 998 "gram.in" */
{ exarif(yypvt[-6].expval, yypvt[-4].labval, yypvt[-2].labval, yypvt[-0].labval);  thiswasbranch = YES; } break;
case 218:
/* # line 1000 "gram.in" */
{ excall(yypvt[-0].namval, LBNULL, 0, labarray); } break;
case 219:
/* # line 1002 "gram.in" */
{ excall(yypvt[-2].namval, LBNULL, 0, labarray); } break;
case 220:
/* # line 1004 "gram.in" */
{ if(nstars < maxlablist)
			excall(yypvt[-3].namval, mklist(revchain(yypvt[-1].chval)), nstars, labarray);
		  else
			many("alternate returns", 'l', maxlablist);
		} break;
case 221:
/* # line 1010 "gram.in" */
{ exreturn(yypvt[-0].expval);  thiswasbranch = YES; } break;
case 222:
/* # line 1012 "gram.in" */
{ exstop(yypvt[-2].ival, yypvt[-0].expval);  thiswasbranch = yypvt[-2].ival; } break;
case 223:
/* # line 1016 "gram.in" */
{ yyval.labval = mklabel( convci(toklen, token) ); } break;
case 224:
/* # line 1020 "gram.in" */
{ if(parstate == OUTSIDE)
			{
			newproc();
			startproc(ESNULL, CLMAIN);
			}
		} break;
case 225:
/* # line 1029 "gram.in" */
{ exgoto(yypvt[-0].labval);  thiswasbranch = YES; } break;
case 226:
/* # line 1031 "gram.in" */
{ exasgoto(yypvt[-0].namval);  thiswasbranch = YES; } break;
case 227:
/* # line 1033 "gram.in" */
{ exasgoto(yypvt[-4].namval);  thiswasbranch = YES; } break;
case 228:
/* # line 1035 "gram.in" */
{ if(nstars < maxlablist)
			putcmgo(putx(fixtype(yypvt[-0].expval)), nstars, labarray);
		  else
			many("labels in computed GOTO list", 'l', maxlablist);
		} break;
case 231:
/* # line 1047 "gram.in" */
{ nstars = 0; yyval.namval = yypvt[-0].namval; } break;
case 232:
/* # line 1051 "gram.in" */
{ yyval.chval = yypvt[-0].expval ? mkchain((char *)yypvt[-0].expval,CHNULL) : CHNULL; } break;
case 233:
/* # line 1053 "gram.in" */
{ yyval.chval = yypvt[-0].expval ? mkchain((char *)yypvt[-0].expval, yypvt[-2].chval) : yypvt[-2].chval; } break;
case 235:
/* # line 1058 "gram.in" */
{ if(nstars < maxlablist) labarray[nstars++] = yypvt[-0].labval; yyval.expval = 0; } break;
case 236:
/* # line 1062 "gram.in" */
{ yyval.ival = 0; } break;
case 237:
/* # line 1064 "gram.in" */
{ yyval.ival = 2; } break;
case 238:
/* # line 1068 "gram.in" */
{ yyval.chval = mkchain((char *)yypvt[-0].expval, CHNULL); } break;
case 239:
/* # line 1070 "gram.in" */
{ yyval.chval = hookup(yypvt[-2].chval, mkchain((char *)yypvt[-0].expval,CHNULL) ); } break;
case 240:
/* # line 1074 "gram.in" */
{ if(parstate == OUTSIDE)
			{
			newproc();
			startproc(ESNULL, CLMAIN);
			}

/* This next statement depends on the ordering of the state table encoding */

		  if(parstate < INDATA) enddcl();
		} break;
case 241:
/* # line 1087 "gram.in" */
{ intonly = YES; } break;
case 242:
/* # line 1091 "gram.in" */
{ intonly = NO; } break;
case 243:
/* # line 1096 "gram.in" */
{ endio(); } break;
case 245:
/* # line 1101 "gram.in" */
{ ioclause(IOSUNIT, yypvt[-0].expval); endioctl(); } break;
case 246:
/* # line 1103 "gram.in" */
{ ioclause(IOSUNIT, ENULL); endioctl(); } break;
case 247:
/* # line 1105 "gram.in" */
{ ioclause(IOSUNIT, IOSTDERR); endioctl(); } break;
case 249:
/* # line 1108 "gram.in" */
{ doio(CHNULL); } break;
case 250:
/* # line 1110 "gram.in" */
{ doio(CHNULL); } break;
case 251:
/* # line 1112 "gram.in" */
{ doio(revchain(yypvt[-0].chval)); } break;
case 252:
/* # line 1114 "gram.in" */
{ doio(revchain(yypvt[-0].chval)); } break;
case 253:
/* # line 1116 "gram.in" */
{ doio(revchain(yypvt[-0].chval)); } break;
case 254:
/* # line 1118 "gram.in" */
{ doio(CHNULL); } break;
case 255:
/* # line 1120 "gram.in" */
{ doio(revchain(yypvt[-0].chval)); } break;
case 256:
/* # line 1122 "gram.in" */
{ doio(CHNULL); } break;
case 257:
/* # line 1124 "gram.in" */
{ doio(revchain(yypvt[-0].chval)); } break;
case 259:
/* # line 1131 "gram.in" */
{ iostmt = IOBACKSPACE; } break;
case 260:
/* # line 1133 "gram.in" */
{ iostmt = IOREWIND; } break;
case 261:
/* # line 1135 "gram.in" */
{ iostmt = IOENDFILE; } break;
case 263:
/* # line 1142 "gram.in" */
{ iostmt = IOINQUIRE; } break;
case 264:
/* # line 1144 "gram.in" */
{ iostmt = IOOPEN; } break;
case 265:
/* # line 1146 "gram.in" */
{ iostmt = IOCLOSE; } break;
case 266:
/* # line 1150 "gram.in" */
{
		ioclause(IOSUNIT, ENULL);
		ioclause(IOSFMT, yypvt[-0].expval);
		endioctl();
		} break;
case 267:
/* # line 1156 "gram.in" */
{
		ioclause(IOSUNIT, ENULL);
		ioclause(IOSFMT, ENULL);
		endioctl();
		} break;
case 268:
/* # line 1164 "gram.in" */
{
		  ioclause(IOSUNIT, yypvt[-1].expval);
		  endioctl();
		} break;
case 269:
/* # line 1169 "gram.in" */
{ endioctl(); } break;
case 272:
/* # line 1177 "gram.in" */
{ ioclause(IOSPOSITIONAL, yypvt[-0].expval); } break;
case 273:
/* # line 1179 "gram.in" */
{ ioclause(IOSPOSITIONAL, ENULL); } break;
case 274:
/* # line 1181 "gram.in" */
{ ioclause(IOSPOSITIONAL, IOSTDERR); } break;
case 275:
/* # line 1183 "gram.in" */
{ ioclause(yypvt[-1].ival, yypvt[-0].expval); } break;
case 276:
/* # line 1185 "gram.in" */
{ ioclause(yypvt[-1].ival, ENULL); } break;
case 277:
/* # line 1187 "gram.in" */
{ ioclause(yypvt[-1].ival, IOSTDERR); } break;
case 278:
/* # line 1191 "gram.in" */
{ yyval.ival = iocname(); } break;
case 279:
/* # line 1195 "gram.in" */
{ iostmt = IOREAD; } break;
case 280:
/* # line 1199 "gram.in" */
{ iostmt = IOWRITE; } break;
case 281:
/* # line 1203 "gram.in" */
{
		iostmt = IOWRITE;
		ioclause(IOSUNIT, ENULL);
		ioclause(IOSFMT, yypvt[-1].expval);
		endioctl();
		} break;
case 282:
/* # line 1210 "gram.in" */
{
		iostmt = IOWRITE;
		ioclause(IOSUNIT, ENULL);
		ioclause(IOSFMT, ENULL);
		endioctl();
		} break;
case 283:
/* # line 1219 "gram.in" */
{ yyval.chval = mkchain((char *)yypvt[-0].tagval, CHNULL); } break;
case 284:
/* # line 1221 "gram.in" */
{ yyval.chval = mkchain((char *)yypvt[-0].tagval, yypvt[-2].chval); } break;
case 285:
/* # line 1225 "gram.in" */
{ yyval.tagval = (tagptr) yypvt[-0].expval; } break;
case 286:
/* # line 1227 "gram.in" */
{ yyval.tagval = (tagptr) mkiodo(yypvt[-1].chval,revchain(yypvt[-3].chval)); } break;
case 287:
/* # line 1231 "gram.in" */
{ yyval.chval = mkchain((char *)yypvt[-0].expval, CHNULL); } break;
case 288:
/* # line 1233 "gram.in" */
{ yyval.chval = mkchain((char *)yypvt[-0].tagval, CHNULL); } break;
case 290:
/* # line 1238 "gram.in" */
{ yyval.chval = mkchain((char *)yypvt[-0].expval, mkchain((char *)yypvt[-2].expval, CHNULL) ); } break;
case 291:
/* # line 1240 "gram.in" */
{ yyval.chval = mkchain((char *)yypvt[-0].tagval, mkchain((char *)yypvt[-2].expval, CHNULL) ); } break;
case 292:
/* # line 1242 "gram.in" */
{ yyval.chval = mkchain((char *)yypvt[-0].expval, mkchain((char *)yypvt[-2].tagval, CHNULL) ); } break;
case 293:
/* # line 1244 "gram.in" */
{ yyval.chval = mkchain((char *)yypvt[-0].tagval, mkchain((char *)yypvt[-2].tagval, CHNULL) ); } break;
case 294:
/* # line 1246 "gram.in" */
{ yyval.chval = mkchain((char *)yypvt[-0].expval, yypvt[-2].chval); } break;
case 295:
/* # line 1248 "gram.in" */
{ yyval.chval = mkchain((char *)yypvt[-0].tagval, yypvt[-2].chval); } break;
case 296:
/* # line 1252 "gram.in" */
{ yyval.tagval = (tagptr) yypvt[-0].expval; } break;
case 297:
/* # line 1254 "gram.in" */
{ yyval.tagval = (tagptr) yypvt[-1].expval; } break;
case 298:
/* # line 1256 "gram.in" */
{ yyval.tagval = (tagptr) mkiodo(yypvt[-1].chval, mkchain((char *)yypvt[-3].expval, CHNULL) ); } break;
case 299:
/* # line 1258 "gram.in" */
{ yyval.tagval = (tagptr) mkiodo(yypvt[-1].chval, mkchain((char *)yypvt[-3].tagval, CHNULL) ); } break;
case 300:
/* # line 1260 "gram.in" */
{ yyval.tagval = (tagptr) mkiodo(yypvt[-1].chval, revchain(yypvt[-3].chval)); } break;
case 301:
/* # line 1264 "gram.in" */
{ startioctl(); } break;
	}
	goto yystack;		/* reset registers in driver code */
}
