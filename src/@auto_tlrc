#!/bin/tcsh -f

if ("$1" == '' || "$1" == "-help" || "$1" == "-h") then
   echo "Usage 1: A script to transform an antomical dataset"
   echo "         to match a template in TLRC space. "
   echo ""
   echo "   `basename $0` [options] <-base template> <-input anat>"
   echo "   Mandatory parameters:"
   echo "      -base template :  Reference anatomical volume in TLRC space (+tlrc)."
   echo "                        Preferably, this reference volume should have had"
   echo "                        the skull removed but that is not mandatory."
   echo "                        AFNI's distribution contains a few templates:"
   echo "                        TT_N27+tlrc --> Single subject, skull stripped volume."
   echo "                                     This volume is also known as "
   echo "                                     N27_SurfVol_NoSkull+tlrc elsewhere in "
   echo "                                     AFNI and SUMA land."
   echo "                                     (www.loni.ucla.edu, www.bic.mni.mcgill.ca)"
   echo "                                     This template has a full set of FreeSurfer"
   echo "                                     (surfer.nmr.mgh.harvard.edu)"
   echo "                                     surface models that can be used in SUMA. "
   echo "                                     For details, see Talairach-related link:"
   echo "                                     http://afni.nimh.nih.gov/afni/suma"
   echo "                        TT_icbm452+tlrc --> Average volume of 452 normal brains."
   echo "                                         Skull Stripped. (www.loni.ucla.edu)"
   echo "                        TT_avg152T1+tlrc --> Average volume of 152 normal brains."
   echo "                                         Skull Stripped.(www.bic.mni.mcgill.ca)"
   echo ""
   echo "                        If you do not specify a path for the template, the script"
   echo "                        will attempt to locate the template AFNI's binaries directory."
   echo ""
   echo "                        NOTE: These datasets have been slightly modified from"
   echo "                              their original size to match the standard TLRC"
   echo "                              dimensions (Jean Talairach and Pierre Tournoux"
   echo "                              Co-Planar Stereotaxic Atlas of the Human Brain"
   echo "                              Thieme Medical Publishers, New York, 1988). "
   echo "                              That was done for internal consistency in AFNI."
   echo "                              You may use the original form of these"
   echo "                              volumes if you choose but your TLRC coordinates"
   echo "                              will not be consistent with AFNI's TLRC database"
   echo "                              (San Antonio Talairach Daemon database), for example."
   echo "      -input anat    :  Original anatomical volume (+orig)."
   echo "                        The skull is removed by this script"
   echo "                        unless instructed otherwise (-no_ss)."
   echo "   Optional parameters:"
   echo "      -no_ss         :  Do not strip skull of input data set"
   echo "                        (because skull has already been removed"
   echo "                        or because template still has the skull)"
   echo "      -pad_base  MM  :  Pad the base dset by MM mm in each directions."
   echo "                        That is needed to  make sure that datasets"
   echo "                        requiring wild rotations do not get cropped."
   echo "                        Default is MM = 40."
   echo "                        If your output dataset is clipped, try increasing"
   echo "                        MM to 50 or 60. If that does not help, make sure"
   echo "                        that the skull-stripped volume has no clipping."
   echo "                        If it does, then the skull stripping needs to"
   echo "                        be corrected. Feel free to report such instances"
   echo "                        to the script's authors." 
   echo "      -keep_tmp      :  Keep temporary files."
   echo "   Example:"
   echo "   `basename $0` -base TT_N27+tlrc. -input DemoSubj_spgrsa+orig."
   echo ""
   echo "Usage 2: A script to transform any dataset by the same TLRC "
   echo "         transform obtained with `basename $0` in Usage 1 mode"
   echo ""
   echo "   `basename $0` [options] <-apar TLRC_parent> <-input dset>"
   echo "   Mandatory parameters:"
   echo "      -apar TLRC_parent : An anatomical dataset in tlrc space"
   echo "                          created using Usage 1 of `basename $0`"
   echo "      -input dset       : Dataset (typically EPI time series or"
   echo "                          statistical datset) to transform to"
   echo "                          tlrc space per the xform in TLRC_parent"
   echo "      -dxyz MM          : Voxel size of output dset in TLRC space."
   echo "                          Default MM is 1." 
   echo "   Example:"
   echo "   `basename $0` -apar DemoSubj_spgrsa+tlrc. -input DemoSubj_EPI+orig."
   echo ""
   echo "Common Optional parameters:"
   echo "   -rmode     MODE:  Resampling mode. Choose from:"
   echo "                     linear, cubic, NN or quintic ."
   echo "                     Default for 'Usage 1' is quintic"
   echo "                     Default for 'Usage 2' is NN"
   echo "   -suffix    SUF :  Name the output dataset by append SUF "
   echo "                     to the prefix of the input data for the output."
   echo "                     Default for SUF is _at"
   echo "   -keep_view     :  Do not mark output dataset as +tlrc"
   echo "   -verb          :  Yakiti yak yak" 
   echo ""
   echo ""
   echo "Written by Ziad S. Saad (ziad@nih.gov)"
   echo "                        SSCC/NIMH/NIH/DHHS"
   echo ""
   goto END
endif
 
PARSE: 
	echo "Parsing ..."
	set Narg = $#
	
	set cnt = 1
   set tmppref = '__ats_tmp_'
   set RemoveSkull = 1
   set KeepView = 0
   set ref_in = ''
   set anat_in = ''
   set apar_mode = 0
   set KeepTmp = 0
   set verb = 0
   set pd = 40
   set suf = "_at"
   set rmode = 'default'
   set dxyz_list = ( 1 1 1 )
   while ($cnt <= $Narg)
		set donext = 1;
      if ($donext && "$argv[$cnt]" == "-rmode") then
         set pLoc = $cnt		
		   if ($pLoc == $Narg) then
				echo "Need string after -rmode"
            goto END
			else
            @ cnt ++
            set rmode = "$argv[$cnt]"
            set donext = 0	
         endif	
      endif
      if ($donext && "$argv[$cnt]" == "-dxyz") then
         set pLoc = $cnt		
		   if ($pLoc == $Narg) then
				echo "Need voxel size after -dxyz"
            goto END
			else
            @ cnt ++
            set dxyz_list[1] = "$argv[$cnt]"
            set dxyz_list[2] = "$argv[$cnt]"
            set dxyz_list[3] = "$argv[$cnt]"
            set donext = 0	
         endif	
      endif
      if ($donext && "$argv[$cnt]" == "-suffix") then
         set pLoc = $cnt		
		   if ($pLoc == $Narg) then
				echo "Need a string after -suffix"
            goto END
			else
            @ cnt ++
            set suf = "$argv[$cnt]"
            set donext = 0	
         endif	
      endif
      if ($donext && "$argv[$cnt]" == "-base") then
         set pLoc = $cnt		
		   if ($pLoc == $Narg) then
				echo "Need template volume after -base"
            goto END
			else
            @ cnt ++
            set ref_in = "$argv[$cnt]"
            set donext = 0	
         endif	
      endif
		if ($donext && "$argv[$cnt]" == "-apar") then
         set pLoc = $cnt		
		   if ($pLoc == $Narg) then
				echo "Need transform volume after -apar"
            goto END
			else
            @ cnt ++
            set ref_in = "$argv[$cnt]"
            set apar_mode = 1
            set donext = 0	
         endif	
      endif
      if ($donext && "$argv[$cnt]" == "-pad_base") then
         set pLoc = $cnt		
		   if ($pLoc == $Narg) then
				echo "Need value after -pad_base"
            goto END
			else
            @ cnt ++
            set pd = "$argv[$cnt]"
            if ($pd > 100 || $pd < 0) then
               echo "Error: -base_pad should be between 0 and 100"
               echo "I have $pd"
               goto END
            endif
            set donext = 0	
         endif	
      endif
      if ($donext && "$argv[$cnt]" == "-input") then
         set pLoc = $cnt		
		   if ($pLoc == $Narg) then
				echo "Need  volume after -input"
            goto END
			else
            @ cnt ++
            set anat_in = "$argv[$cnt]"
            set donext = 0	
         endif	
      endif
      if ($donext && "$argv[$cnt]" == "-no_ss") then
         set RemoveSkull = 0;		
         set donext = 0		
      endif
      if ($donext && "$argv[$cnt]" == "-keep_view") then
         set KeepView = 1;		
         set donext = 0		
      endif
      if ($donext && "$argv[$cnt]" == "-keep_tmp") then
         set KeepTmp = 1;		
         set donext = 0		
      endif
      if ($donext && "$argv[$cnt]" == "-verb") then
         set verb = 1;		
         set donext = 0		
      endif
      if ($donext == 1) then
         echo "Error: Option or parameter '$argv[$cnt]' not understood"
         goto END
      endif
		@ cnt ++
	end
   if ("$anat_in" == "" || "$ref_in" == "") then
      echo "Error: Need both -base and -input parameters"
      goto END
   endif
   
   goto SET_REF_PATH
   SET_REF_PATH_RETURN:
   #echo "Template/Apar path is: $ref_path"
   
   set anat_path = $anat_in:h
   if ( "$anat_path" == "${anat_in}" ) set anat_path = "."

   
   
   #At the moment, must have . for anat_path
   #It looks like 3drefit does not like an input dset with a path
   if ( "$anat_path" != "." ) then
      echo "Error: input dataset must be in the current directory"
      echo "Current path for input dataset is $anat_path"
      echo "Sorry."
      goto END
   endif
   
   #if in apar mode, no need for skull strippin 
   if ($apar_mode == 1) then
      set RemoveSkull = 0
   endif
   
   #set default rmode
   if ("$rmode" == "default") then
      if ($apar_mode == 1) then
         set rmode = "NN"
      else
         set rmode = "quintic"
      endif
   endif
   
   #figure out resample's mode, based on rmode
   if ("$rmode" == "quintic") then
      set resam = "Bk"
   else if ("$rmode" == "cubic") then
      set resam = "Cu"
   else if ("$rmode" == "linear") then
      set resam = "Li"
   else if ("$rmode" == "NN") then
      set resam = "NN"
   else
      echo "Error: Bad resampling option $rmode"
      goto END
   endif
   
   set ref_pref_nopad = "${ref_path}/`@GetAfniPrefix ${ref_in}`"
   set ref_pref_pad  = "${tmppref}_ref_`@GetAfniPrefix ${ref_in}`_${pd}pad"
   set ref_view = `@GetAfniView ${ref_in}`
   set anat_pref = "${anat_path}/`@GetAfniPrefix ${anat_in}`"
   if ($RemoveSkull == 1) then
      set ns_pref = ${anat_pref}_ns
   else
      set ns_pref = ${anat_pref}
   endif
   set rs_pref = ${anat_pref}_rs
   set tt_pref = ${anat_pref}${suf}

IN_CHECK:
if ( `@CheckForAfniDset ${ref_in}` != 2 ) then
   echo "Error: Template dset ${ref_in} not found."
   goto END
endif
if ( `@CheckForAfniDset ${anat_in}` != 2 ) then
   echo "Error: Anatomical dset ${anat_in} not found."
   goto END
endif 

if ($KeepView == 1) then
   if ( `@CheckForAfniDset ${tt_pref}+orig` != 0 ) then
      echo "Error: Output dset ${tt_pref}+orig exists"
      goto END
   endif
else
   if ( `@CheckForAfniDset ${tt_pref}+tlrc` != 0 ) then
      echo "Error: Output dset ${tt_pref}+tlrc exists"
      goto END
   endif
endif

if ($apar_mode == 1) then
   goto APAR_MODE
else
   goto AUTO_TLRC_MODE
endif

#######################
#Begin auto tlrc block
#######################
AUTO_TLRC_MODE:
   #cleanup in case cleanup was not done in last execution
   set Ret_Clean = PAD
   goto CLEANUP

   PAD:
   #Paddin the reference since tt vols are perrty tight
   if ( `@CheckForAfniDset ${ref_pref_pad}${ref_view}` == 0 ) then
      echo "Padding ..."
      3dZeropad -I $pd -S $pd -A $pd -P $pd -L $pd -R $pd -mm -prefix ./${ref_pref_pad} ${ref_in}
   endif

   SS:
   #Skully Strippin, Brainy Sniffing
   if ( ! -f ${ns_pref}+orig.HEAD ) then
      echo "Skull Stripping ..."
      3dSkullStrip -input ${anat_pref}+orig -prefix ${ns_pref}
      if ( ! -f ${ns_pref}+orig.HEAD ) then
         echo "Error: Failed to create skull stripped brain"
         goto END
      endif
   else
      if ($RemoveSkull == 1) then
         echo "Reusing skull stripped volume ${ns_pref}+orig found on disk."
      endif
   endif

   RES:
   #Resamplin
   if ( ! -f ${rs_pref}+orig.HEAD ) then
      echo "Resampling ..."
      rm -f ${tmppref}_resamp* >& /dev/null
      #Use cubic for somoothness of result since it will be used in registration.
      #But that causes edge artifacts from interpolation. Use a resampled mask to cleanup
      3dresample -rmode Cu -master ${ref_pref_pad}+tlrc -inset ${ns_pref}+orig -prefix ${tmppref}_resamp_edge_art
      3dcalc -a "${ns_pref}+orig" -expr "step(a)*10000" -prefix ${tmppref}_resamp_step
      3dresample -rmode Linear -master ${ref_pref_pad}+tlrc -inset ${tmppref}_resamp_step+orig -prefix ${tmppref}_resamp_NN
      3dcalc   -a "${tmppref}_resamp_edge_art+tlrc." -b "${tmppref}_resamp_NN+tlrc." \
               -expr "a*step(b-5000)" -prefix ${tmppref}_resamp
      if ( ! -f ${tmppref}_resamp+tlrc.HEAD) then
         echo "Error: Failed to create resampled volume"
         goto END
      endif
      #clip values to range of input
      set range = `3dMax -min -max ${ns_pref}+orig`
      set min = `ccalc -eval "$range[1] - 0.0001"`
      set max = `ccalc -eval "$range[2] + 0.0001"`
      echo "Clipping $min $max ..."
      3dcalc   -a ${tmppref}_resamp+tlrc -expr "a*step(a-$min)*step($max-a) + $range[1]*step($range[1]-a) + $range[2]*step(a-$range[2])" \
               -prefix ${rs_pref} 
      3drefit -view orig ${rs_pref}+tlrc.HEAD
      3drefit -view orig ${tmppref}_resamp_NN+tlrc.HEAD
      3drefit -view orig ${tmppref}_resamp_edge_art+tlrc.HEAD
      if ( $KeepTmp == 0) rm -f ${tmppref}_resamp* >& /dev/null 
      if ( ! -f ${rs_pref}+orig.HEAD ) then
         echo "Error: Failed to change view of resampled volume"
         goto END
      endif
   endif

   REG:
   #Registration
   echo "Registration ($rmode final interpolation) ..."
   if ( $KeepTmp == 0) rm -f ${tmppref}_reg* >& /dev/null 
   set spopt = ''
   if ($verb == 1) then
      set spopt = "$spopt -verb"
   endif
   3dWarpDrive ${spopt} -twopass -affine_general -cubic  \
               -final ${rmode} -base ${ref_pref_pad}+tlrc \
               -prefix ${tmppref}_reg_warpdriveout -input ${rs_pref}+orig
   if ( ! -f ${tmppref}_reg_warpdriveout+orig.HEAD ) then
      echo "Error: Failed in 3dWarpDrive "
      goto END
   endif
   #apply same warp for mask of dataset and use mask to get rid of edge artifacts
   3dcalc -a "${rs_pref}+orig" -expr "step(a)*10000" -prefix ${tmppref}_reg_braintlrcstep
   3dWarp -matparent ${tmppref}_reg_warpdriveout+orig -linear -prefix ${tmppref}_reg_braintlrcmask ${tmppref}_reg_braintlrcstep+orig 
   3dcalc   -a "${tmppref}_reg_braintlrcmask+orig" \
            -b "${tmppref}_reg_warpdriveout+orig" \
            -expr "step(a-5000)*b" -prefix ${tt_pref}_${pd}pad
   if ( ! -f ${tt_pref}_${pd}pad+orig.HEAD ) then
      echo "Error: Failed to create tlrced brain"
      goto END
   endif
   
   UNPAD:
   #unPadding the anatomical 
   echo "Unpadding ..."
   3dZeropad   -I -$pd -S -$pd -A -$pd -P -$pd -L -$pd -R -$pd -mm \
               -prefix ${tt_pref} ${tt_pref}_${pd}pad+orig
   #copy the WARPDRIVE_MATVEC_ fields to the zero unpadded dude
   3drefit -atrcopy ${tmppref}_reg_warpdriveout+orig WARPDRIVE_INPUT_IDCODE ${tt_pref}+orig
   3drefit -atrcopy ${tmppref}_reg_warpdriveout+orig WARPDRIVE_INPUT_NAME ${tt_pref}+orig
   3drefit -atrcopy ${tmppref}_reg_warpdriveout+orig WARPDRIVE_BASE_IDCODE ${tt_pref}+orig
   3drefit -atrcopy ${tmppref}_reg_warpdriveout+orig WARPDRIVE_MATVEC_FOR_000000 ${tt_pref}+orig
   3drefit -atrcopy ${tmppref}_reg_warpdriveout+orig WARPDRIVE_MATVEC_INV_000000 ${tt_pref}+orig
   
   if ($KeepView == 0) then
      echo "Changing view of transformed anatomy"
      3drefit -view +tlrc ${tt_pref}+orig.HEAD
   endif

   goto WRAP_UP
#######################
#end of auto tlrc block
#######################

#######################
#Begin apar block
#######################
APAR_MODE:
   echo "Applying tlrc warp from ${ref_pref_nopad}${ref_view} to ${ns_pref}+orig ..."
   if ( -f warp_tmp+orig.HEAD) then
      rm -f warp_tmp+orig.HEAD warp_tmp+orig.BRIK
   endif
   echo "Warping per parent transform ($rmode interpolation) ..."
   3dWarp -matparent ${ref_pref_nopad}${ref_view} -prefix warp_tmp -${rmode} ${ns_pref}+orig
   if ( ! -f warp_tmp+orig.HEAD) then
      echo "Error: Failed to create tlrced dset"
      goto END
   endif
   echo "Resampling to fit tlrc box ($resam interpolation) ..."
   3dresample  -master ${ref_in} -dxyz ${dxyz_list[1]} ${dxyz_list[2]} ${dxyz_list[3]} \
               -prefix ${tt_pref} -inset warp_tmp+orig -rmode ${resam}  
   if ( $KeepTmp == 0) rm -f warp_tmp+orig.HEAD warp_tmp+orig.BRIK >& /dev/null
   
   goto WRAP_UP
#######################
#End of apar block
#######################


WRAP_UP:
#this time, cleanup and goto END
if ($KeepTmp != 1) then 
   set Ret_Clean = END
   echo "Cleanup ..."
   goto CLEANUP
else
   goto END
endif


goto END


CLEANUP:
rm -f ${tmppref}_ref* >& /dev/null
rm -f ${tmppref}_reg* >& /dev/null
rm -f ${tmppref}_resam* >& /dev/null
rm -f ${rs_pref}+orig.HEAD ${rs_pref}+orig.BRIK >& /dev/null
rm -f ${tt_pref}_${pd}pad+orig.HEAD ${tt_pref}_${pd}pad+orig.BRIK >& /dev/null
goto $Ret_Clean

SET_REF_PATH:
set ref_path = $ref_in:h
if ( "$ref_path" == "$ref_in" ) then
   #echo "No Path specified ( $ref_path == $ref_in )" 
   set ref_path = "."
   if ($apar_mode == 1) then
      goto SET_REF_PATH_RETURN
   endif
   #if not in apar mode, try to set the path
   if ( `@CheckForAfniDset ${ref_in}` == 2 ) then
      echo "Template dset ${ref_in} found."
      goto SET_REF_PATH_RETURN
   endif
   #search where afni is
   set wa = `which afni`
   if ( $status != 0) then
      echo "Error: afni not located"
      goto END
   endif
   set ref_path = "$wa:h"
   if ( "$ref_path" == "$wa" ) then
      set ref_path = "."
      echo "Error: Template $ref_in could not be located"
      goto END
   endif
   #echo "try finding ref_in in new ref_path"
   if ( `@CheckForAfniDset ${ref_path}/${ref_in}` != 2 ) then
      echo "Error: Template dset ${ref_in} not found in afni's binaries directory"
      goto END
   endif
   echo "Using template from ${ref_path} ..."
   set ref_in = ${ref_path}/${ref_in}
else
   #echo "Path specified (${ref_path}), stay out of this"
endif
goto SET_REF_PATH_RETURN

END:
