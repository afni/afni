#!/bin/tcsh

set do_help = 0
if( $#argv == 0 ) set do_help = 1
if( $do_help == 0 )then
  if( "$argv[1]" == "-help" ) set do_help = 1
endif
if( $do_help )then
  echo "Usage: @grayplot [OPTIONS] dirname"
  echo
  echo "Script to read files from an afni_proc.py results directory"
  echo "and produce a grayplot from the errts dataset, combined with"
  echo "a motion magnitude indicator graph."
  echo
  echo "Will produce a plot for errts.SUBJECT+tlrc and for"
  echo "errts.SUBJECT_REML+tlrc, if both datasets were computed."
  echo "And errts.SUBJECT_REMLwh+tlrc will also be plotted, if option"
  echo "'-regress_opts_reml -Rwherr errts.SUBJECT_REMLwh' was given"
  echo "to afni_proc.py -- this is the 'pre-whitened' residuals dataset."
  echo "The output images are grayscale, stored in .png format, and"
  echo "have names like 'Grayplot.errts.SUBJECT.ORDERMETH.png'."
  echo "* See the OPTIONS section below for the ordering methods"
  echo "  of the voxels in the output."
  echo "* SUBJECT is the subject ID code, extracted from the dataset name"
  echo "  'anat_final.SUBJECT+tlrc.HEAD'."
  echo
  echo "Note that time points which were censored out will have errts=0"
  echo "(and thus look flat), and the motion magnitude graph will be"
  echo "set to 0 at these points as well -- to avoid having large motions"
  echo "dominate the graph and make it hard to see other movements."
  echo "Censored time points are also overlaid with gray band in the"
  echo "graph above the dataset grayplot. (Gray so that the resulting"
  echo "png file is grayscale, without color.)"
  echo
  echo "If the afni_proc.py setup was a task analysis, and if option"
  echo "'-regress_make_ideal_sum sum_ideal.1D' was used, the 'sum_ideal.1D'"
  echo "file will also be graphed above the motion magnitude graphed, to make"
  echo "it possible to see if the dataset grayplot has stimulus-correlated"
  echo "bands of data."
  echo
  echo "Segments the anatomy (or uses an existing segmentation, if"
  echo "it was run by afni_proc.py), and grayplots the GM, WM, and CSF"
  echo "voxels separately from top to bottom, with dashed lines dividing"
  echo "the partitions."
  echo
  echo "COMMAND LINE ARGUMENTS"
  echo "* The last argument is the afni_proc.py results directory."
  echo "  To use the current working directory, use '.' as the last argument."
  echo "* The only OPTIONS at this time control the ordering of the voxel"
  echo "  (time series)graphs inside each mask partition in the grayplot,"
  echo "  downward in the image:"
  echo "    -pvorder ="
  echo "      Within each partition, voxels are ordered by a simple similarity"
  echo "      measure, so the top of each partition will echo have voxel time"
  echo "      series that are more similar than the bottom of the partition."
  echo "      This ordering helps make it clear if there are many time series"
  echo "      with similar temporal patterns, which will show up as vertical"
  echo "      bands in the grayplot."
  echo "    -peelorder ="
  echo "      Within each partition, voxels are ordered by how many 'peel'"
  echo "      operations are needed to reach a given voxel; that is, how"
  echo "      far a voxel is from the partition's boundary. Voxels at the"
  echo "      edge of the partition are first, etc."
  echo "  The default (no option given) order is simple coordinate order"
  echo "  in the dataset, which may not be very interesting."
  echo
  echo "Author: RWCox -- May 2018"
  echo "Notice: Subject to drastic change at any instant"
  exit 0
endif

set order = " "
set osuff = "XYZORDER.png"
set ddir  = "."
set iarg  = 0

if( $#argv > 0 )then
  set iarg = 1
  if( "$argv[$iarg]" == "-peelorder" )then
    set order = "-peelorder" ; set osuff = "PEELORDER.png" ; @ iarg ++
  else if( "$argv[$iarg]" == "-pvorder" )then
    set order = "-pvorder" ; set osuff = "PVORDER.png" ; @ iarg ++
  endif
  if( $#argv >= $iarg )then
    set ddir = $argv[$iarg] ; @ iarg ++
  endif
endif

pushd $ddir

# find anat file, extract subj name from it

set aa = ( anat_final.*+tlrc.HEAD )
if( $#aa != 1 )then
  echo "Can't find anat_final.*+tlrc.HEAD" ; exit 1
endif

set subj = `echo $aa[1] | sed -e 's/+tlrc.HEAD//' -e 's/anat_final.//'`

# find EPI mask file

set dmask = mask_epi_anat.${subj}+tlrc.HEAD
if( ! -f $dmask )then
  set dmask = full_mask.${subj}+tlrc.HEAD
  if( ! -f $dmask )then
    echo "** Can't find EPI mask :(" ; exit 1
  endif
endif

echo "----- Plotting motion"

# compute enorm from each run's dfile

set dlist = ( dfile.r*.1D )
set nrun  = $#dlist

foreach ddd ( $dlist )
  1d_tool.py -infile $ddd -derivative -collapse_cols euclidean_norm \
             -write enorm.$ddd
end

# glue them together

\rm -f enorm.dfile.all*
cat enorm.dfile.r*.1D > enorm.dfile.allU.1D
\rm enorm.dfile.r*.1D

# find the censoring file

set ccc = censor_${subj}_combined_2.1D
if( ! -f $ccc )then
  set ccc = motion_${subj}_censor.1D
  if( ! -f $ccc )then
    set ccc = outcount_${subj}_censor.1D
    if( ! -f $ccc )then
      unset ccc
    endif
  endif
endif

# make the naked enorm plots

setenv AFNI_1DPLOT_COLOR_01   'black'
set    cencol               = '#dddddd'
if( $?ccc )then
  1deval -a enorm.dfile.allU.1D -b $ccc -expr 'a*b' > enorm.dfile.allC.1D
endif

if( -f enorm.dfile.allC.1D && -f sum_ideal.1D )then
  1dplot -nopush -naked -sep_scl -pnms 1000 enorm.dfile.allC.ppm -aspect 10 \
         -censor_RGB $cencol -censor $ccc enorm.dfile.allC.1D sum_ideal.1D
  1dplot -nopush -naked -sep_scl -pnms 1000 enorm.dfile.allU.ppm -aspect 10 \
         -censor_RGB $cencol -censor $ccc enorm.dfile.allU.1D sum_ideal.1D
else if( -f enorm.dfile.allC.1D && ! -f sum_ideal.1D )then
  1dplot -nopush -naked -pnms 1000 enorm.dfile.allC.ppm -aspect 10 \
         -censor_RGB $cencol -censor $ccc enorm.dfile.allC.1D
  1dplot -nopush -naked -pnms 1000 enorm.dfile.allU.ppm -aspect 10 \
           -censor_RGB $cencol -censor $ccc enorm.dfileU.all.1D
endif

if( ! -f enorm.dfile.allU.ppm && -f sum_ideal.1D )then
  1dplot -nopush -naked -sep_scl -pnms 1000 enorm.dfile.allU.ppm -aspect 10 \
         enorm.dfile.allU.1D sum_ideal.1D
else if( ! -f enorm.dfile.allU.ppm && ! -f sum_ideal.1D )then
  1dplot -nopush -naked -pnms 1000 enorm.dfile.allU.ppm -aspect 10 \
         enorm.dfile.allU.1D
endif

if( ! -f enorm.dfile.allC.ppm )then
  \cp -f enorm.dfile.allU.ppm enorm.dfile.allC.ppm
endif

# make a mask of GM, WM, and CSF (in that order)

if( -f Classes+tlrc.HEAD )then
  echo "----- Using existing segmentation"
else
  echo "----- Segmenting $aa[1]"
  3dSeg -anat $aa[1] -mask AUTO -blur_meth BIM -classes 'CSF; GM; WM'
  if( -f Segsy/Classes+tlrc.HEAD ) mv Segsy/Classes+tlrc.* .
  \rm -rf Segsy
endif

if( -f Classes+tlrc.HEAD )then
# convert CSF=1 to CSF=4
  3dcalc -a Classes+tlrc.HEAD -expr 'ifelse(equals(a,1),4,a)' \
         -datum byte -nscale -prefix GmaskA.nii
# convert from anat resolution to EPI resolution
  3dfractionize -template $dmask \
                -input GmaskA.nii -prefix GmaskB.nii -vote
# combine with EPI mask
  3dcalc -a GmaskB.nii -b $dmask -expr 'a*b' -prefix GmaskC.nii
  set ggg = GmaskC.nii
  \rm -rf GmaskA.nii GmaskB.nii
else
  set ggg = $dmask
endif

# grayplot both errts files, if they both exist

set eaa = errts.${subj}+tlrc.HEAD
set ebb = errts.${subj}_REML+tlrc.HEAD
set ecc = errts.${subj}_REMLwh+tlrc.HEAD

foreach eee ( $eaa $ebb $ecc )
  if( -f $eee )then
    echo "----- Grayplot $eee"
    set ppp = `basename $eee +tlrc.HEAD`
    3dGrayplot -dimen 1000 500      \
               $order               \
               -polort -1           \
               -mask $ggg           \
               -input $eee          \
               -prefix G.errts.pgm
# merge with graph
    pnmcat -tb enorm.dfile.allC.ppm G.errts.pgm | \
      pnmtopng - > Grayplot.${ppp}.${osuff}
    echo " ---- Result in $cwd/Grayplot.${ppp}.${osuff}"
    \rm G.errts.pgm
  endif
end

# grayplot the all_runs file

@ port = 2 * $nrun

foreach eee ( all_runs.${subj}+tlrc.HEAD )
  if( -f $eee )then
    echo "----- Grayplot $eee"
    set ppp = `basename $eee +tlrc.HEAD`
    3dGrayplot -dimen 1000 500      \
               $order               \
               -polort $port        \
               -mask $ggg           \
               -input $eee          \
               -prefix G.errts.pgm
# merge with graph
    pnmcat -tb enorm.dfile.allU.ppm G.errts.pgm | \
      pnmtopng - > Grayplot.${ppp}.${osuff}
    echo " ---- Result in $cwd/Grayplot.${ppp}.${osuff}"
    \rm G.errts.pgm
  endif
end

# remove the trash

\rm enorm.dfile.all*
if( -f GmaskC.nii ) \rm GmaskC.nii

exit 0
