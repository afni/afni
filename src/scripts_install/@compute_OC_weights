#!/bin/tcsh

# compute optimally combining weights for echoes
#
# inputs:  echo times and one run of multi-echo EPI data
# outputs: a multi-volume dataset of voxelwise weights
#
# use:     OC for a run would be the sum of each echo time series times
#          its computed weight.
#
#          Voxels that do not solve to an appropriate decay will get the
#          average of the echoes (unless a better idea comes along).
#
# Should this be left as a little script or turned into a
# more formal python program?  Either way, add some options...

# system of equations from Javier's presentation:
#
#   log(mean(S(TE_1))) ~= -mean(R2s(x))*TE_1 + log(So(x))
#   log(mean(S(TE_2))) ~= -mean(R2s(x))*TE_2 + log(So(x))
#   log(mean(S(TE_3))) ~= -mean(R2s(x))*TE_3 + log(So(x))
#
# Then T2* = 1/mean(R2s(x)), and weights come from:
#
#                TE_n*e^-(TE_n/T2*)
#   w(TE_n) = -------------------------
#             sum_n[TE_n*e^-(TE_n/T2*)]
#
#
# Note that T2* is the reciprocal of m(R2s), and that it is subsequently
# applied via TE_n/T2*.  So apply via T2s_inv (multiplicative), to avoid
# repeated division.
# 
# 
# ** bad voxels (e.g. m(R2s)<0) will get weights of 1.0/necho


set VERSION = 0.3
set prog = @compute_OC_weights


set def_to_equal = 1
set echo_dsets = ()
set etimes_file = ''
set necho = 0
set prefix = OC_weights
set t2s_limit = 300
set tolerance = 0.001
set work_dir = OC.weight.results
set verb = 1

set root_dir = `pwd`

if ( $#argv < 1 ) goto HELP

set ac = 1
while ( $ac <= $#argv )
   if ( "$argv[$ac]" == "-help" || "$argv[$ac]" == "-h" ) then
      goto HELP
   else if ( "$argv[$ac]" == "-hist" ) then
      goto HIST

   else if ( "$argv[$ac]" == "-def_to_equal" ) then
      @ ac ++
      if ( $ac > $#argv ) then
         echo "** missing parameter for option '-def_to_equal'"
         exit 1
      endif
      if ( "$argv[$ac]" == yes ) then
         set def_to_equal = 1
      else if ( "$argv[$ac]" == no ) then
         set def_to_equal = 0
      else
         echo "** -def_to_equal requires yes/no, have $argv[$ac]"
         exit 1
      endif

   else if ( "$argv[$ac]" == "-echo_dsets" ) then
      @ ac ++
      set acbase = $ac
      while ( $ac <= $#argv )
         set o0 = "`echo $argv[$ac] | cut -b 1`"
         if ( "$o0" == '-' ) break
         # have something
         @ ac += 1
      end

      # ac index is never good here
      @ ac -= 1

      if ( $ac < ($acbase + 1) ) then
         echo "** -echo_dsets requires at least 2 datasets"
         exit 1
      endif

      # take them as echo datasets
      set echo_dsets = ( $argv[$acbase-$ac] )

   else if ( "$argv[$ac]" == "-echo_times_file" ) then
      @ ac ++
      if ( $ac > $#argv ) then
         echo "** missing parameter for option '-echo_times_file'"
         exit 1
      endif
      set etimes_file = $argv[$ac]

   else if ( "$argv[$ac]" == "-prefix" ) then
      @ ac ++
      if ( $ac > $#argv ) then
         echo "** missing parameter for option '-prefix'"
         exit 1
      endif
      set prefix = $argv[$ac]

   else if ( "$argv[$ac]" == "-sum_weight_tolerance" ) then
      @ ac ++
      if ( $ac > $#argv ) then
         echo "** missing parameter for option '-sum_weight_tolerance'"
         exit 1
      endif
      set tolerance = $argv[$ac]
   else if ( "$argv[$ac]" == "-work_dir" ) then
      @ ac ++
      if ( $ac > $#argv ) then
         echo "** missing parameter for option '-work_dir'"
         exit 1
      endif
      set work_dir = $argv[$ac]
   else if ( "$argv[$ac]" == "-t2_star_limit" ) then
      @ ac ++
      if ( $ac > $#argv ) then
         echo "** missing parameter for option '-t2_star_limit'"
         exit 1
      endif
      set t2s_limit = $argv[$ac]
   else if ( "$argv[$ac]" == "-verb" ) then
      @ verb += 1
      if ( $verb > 2 ) then
         set echo
      endif
   else
      echo "** bad option $ac : '$argv[$ac]'"
   endif

   @ ac += 1
end

# maybe chat a little
if ( $verb > 1 ) then
   echo "++ have $#echo_dsets echo datasets"
   echo "++ echo_times_file = $etimes_file"
   echo "++ output prefix = $prefix"
   echo "++ work_dir = $work_dir"
   echo "++ t2_star_limit = $t2s_limit"
   echo ""
endif

# check for required parameters
if ( ! -f "$etimes_file" ) then
   echo "** missing -echo_times_file $etimes_file"
   exit 1
endif

if ( $#echo_dsets < 2 ) then
   echo "** must have at least 2 -echo_dsets files"
   exit 1
endif

# check for echo times, and compare against num EPI datasets
set necho = `1dcat $etimes_file | wc -w`
if ( $necho == 0 ) then
   echo "** missing -echo_times_file $etimes_file"
   exit 1
endif

if ( $necho != $#echo_dsets ) then
   echo "** have $necho echo times, but $#echo_dsets echo datasets"
   exit 1
endif


# try to set the view
set view = `3dinfo -av_space $echo_dsets[1]`
if ( "$view" == "NO-DSET" || "$view" == "" ) then
   echo "** failed to set view from $echo_dsets[1]"
   exit 1
endif

if ( $verb ) echo "-- have $necho echoes"
if ( $verb == 2 ) echo "-- have view $view"

set eind_list = ( `count -digits 1 1 $necho` )

if ( -d $work_dir ) then
   echo "** output dir $work_dir already exists, exiting..."
   exit 1
endif

mkdir $work_dir

# ----------------------------------------------------------------------
# get inputs or basic computations into working directory

# get means for each echo
foreach eind ( $eind_list ) 
   3dTstat -mean -prefix $work_dir/s1.mean.e$eind $echo_dsets[$eind]
end

# copy echo times file into working dir and adjust var
# (also, force them to be verticle, just to be safe)
set etimes = ( `cat $etimes_file` )
set etimes_file = $etimes_file:t
echo $etimes | tr ' ' '\n' > $work_dir/$etimes_file

# ----------------------------------------------------------------------
# enter results dir and proceed
cd $work_dir

# get means for each echo
foreach eind ( $eind_list ) 
   3dcalc -a s1.mean.e$eind$view -expr 'log(a)' -prefix s2.log.e$eind
end

# "temporal" catenation
3dTcat -TR 1 -prefix s3.tcat.logs s2.log.e*.HEAD


# regress to solve for R(x) and log(So(x))
3dDeconvolve -input s3.tcat.logs$view   \
        -polort 0                       \
        -num_stimts 1                   \
        -stim_file 1 $etimes_file       \
        -x1D x.xmat.1D                  \
        -fitts s4.fitts                 \
        -bucket s4.bucket               \
        -bout

# output volumes are:
#    0 : full-F
#    1 : constant term : log(S0(x))
#    2 : linear term   : -R2(x)

# separate T2-star volume (basically -1/T2star, but with limits)
# also: compute 1/T2*, to use multiplication rather than repeated division
#       (so no t2s_limit?)
# also: specifying float should not be necessary, but let's be sure
#       (float will propagate)
3dcalc -a s4.bucket$view'[2]' -expr "step(-a)*min(-1/a,$t2s_limit)" \
       -datum float -prefix s5.t2.star
3dcalc -a s4.bucket$view'[2]' -expr "-a*step(-a)" \
       -datum float -prefix s5.t2.star.inv

# make a product time series (for any <= 0 values, replace with 1)
# TE_n * e^-(TE_n/t2star)
# ** use 1/T2* here, so product is   TE_n * e^-(TE_n * t2s_inv)
3dcalc -a s5.t2.star.inv$view -b $etimes_file \
       -expr 'step(a)*b*exp(-b*a)' -prefix s6.prod

# and sum for weight denominator
3dTstat -sum -prefix s7.sum.te s6.prod$view

# make a time series of weights per echo, which is now just prod/sum
# (guard against truncation errors by limiting to 1)
3dcalc -a s6.prod$view -b s7.sum.te$view -expr 'min(a/b,1)' \
       -prefix s8.weight.orig
set result_dset = s8.weight.orig

# as a safeguard, mask the weights by voxels with valid sums
# (within 'tolerance' of 1)
3dTstat -sum -prefix s9.sum.weights s8.weight.orig$view
3dcalc -a s9.sum.weights$view -prefix s9.tolerance.fail \
       -expr "step(a)*(1-within(a,1-$tolerance,1+$tolerance))"
3dcalc -a s9.sum.weights$view -prefix s9.tolerance.mask \
       -expr "within(a,1-$tolerance,1+$tolerance)"

# if default is mean across echoes, insert into result
if ( $def_to_equal ) then
   set wval = `ccalc 1/$necho`
   3dcalc -a s8.weight.orig$view -b s9.tolerance.mask$view \
          -expr "bool(b)*a+(1-bool(b))*$wval" -prefix s10.masked.weights
else
   3dcalc -a s8.weight.orig$view -b s9.tolerance.mask$view \
          -expr 'a*b' -prefix s10.masked.weights
endif
set result_dset = s10.masked.weights
        

# copy back to $prefix
cd $root_dir
3dbucket -prefix $prefix $work_dir/$result_dset$view

if ( $status ) then
   echo "** failed to create $prefix"
else if ( $verb ) then
   echo "++ output written to $prefix"
endif

exit 0


# ===========================================================================
# show help 
HELP:
cat << EOF

$prog           - compute optimally combined weights dataset

   Given echo times (in a text file) and one run of multi-echo EPI data,
   compute a dataset that can be used to combine the echoes.  The weight
   dataset would have one volume per echo, which can be used to combine
   the echoes into a single dataset.  The same echoes can be applied to
   all runs.

    3dcalc -a echo1+tlrc        -b echo2+tlrc        -c echo3+tlrc        \
           -d weights+tlrc'[0]' -e weights+tlrc'[1]' -f weights+tlrc'[2]' \
           -expr 'a*d+b*e+c*f'  -prefix opt.combined

   ----------------------------------------------------------------------

   These computations are based on the system of equations from the summer
   2017 presentation by Javier Gonzalez-Castillo.  After solving:
  
     log(mean(S(TE_1))) ~= -mean(R2s(x))*TE_1 + log(So(x))
     log(mean(S(TE_2))) ~= -mean(R2s(x))*TE_2 + log(So(x))
     log(mean(S(TE_3))) ~= -mean(R2s(x))*TE_3 + log(So(x))
  
   then T2* = 1/mean(R2s(x)), and weights come from:
  
                  TE_n*e^-(TE_n/T2*)
     w(TE_n) = -------------------------
               sum_n[TE_n*e^-(TE_n/T2*)]

   Bad, naughty voxels are defined as those with either negative T2* values,
   or for which the sum of the weights is not sufficiently close to 1, which
   would probably mean that there were computational truncation errors, likely
   due to R2s being very close to 0.

   so "fail" if
         mean(R2s) <= 0
   or
         abs(1-sum[weights]) > 'tolerance'

   In such cases, the weights will default to 1/number_of_echoes.
  
   ----------------------------------------------------------------------

   examples:

      1. basic

         @compute_OC_weights -echo_times_file etimes.1D \\
                -echo_dsets pb02*r01*volreg*.HEAD
  
      2. specify working directory and resulting weights dataset prefix

         @compute_OC_weights -echo_times_file etimes.1D \\
                -echo_dsets pb02*r01*volreg*.HEAD       \\
                -prefix OC.run1 -work_dir OC.work.run1

   ----------------------------------------------------------------------

   required parameters:

      -echo_times_file FILE     - specify file with echo times
                                  (e.g. it could contain 15 30.5 41)

      -echo_dsets D1 D2 D3      - specify one run of multi-echo EPI data, e.g.:

         e.g. -echo_dsets pb03.SUBJ.r01.e*.volreg+tlrc.HEAD


   general options:

      -def_to_equal yes/no      - specify whether to default to equal weights
                                  (default = yes)

        In the case where T2* seems huge or <= 0, or if the sum of the
        fractional weights is not close to 1 (see -tolerance), one might
        want to apply default weights equal to 1/num_echoes (so echoes
        are weighted equally).

      -prefix PREFIX            - specify prefix of resulting OC weights dataset

           e.g. -prefix OC.weights.SUBJ

      -t2_star_limit LIMIT      - specify limit for T2* values (default 300)

        This is not too important, as bad T2* values should be handled by
        -def_to_equal.

      -work_dir WDIR            - specify directory to compute results in

      -verb                     - increase verbosity of output


   terminal options:

       -help
       -hist
       -ver

   ----------------------------------------------------------------------
   R Reynolds, Feb, 2016               Thanks to Javier Gonzalez-Castillo
  
EOF
exit


# ===========================================================================
# show history 
HIST:
cat << EOF

modification history for $prog :

   0.0  12 Feb 2018 : started
   0.1  16 Feb 2018 : ready for use (added -def_to_equal)
   
EOF
exit
