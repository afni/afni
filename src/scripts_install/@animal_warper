#!/bin/tcsh 

@global_parse `basename $0` "$*" ; if ($status) exit 0

# affine alignment of individual dataset to a template
#  handcrafted for macaque alignment originally - D99 and NMT templates
# usage example:
#     @animal_warper  -input macaque1+orig \
#	      -base ../NMT.nii.gz 				\
#	      -atlas ${atlas_dir}/D99_atlas_1.2a_al2NMT.nii.gz
# see help section at end for options
# derived from macaque_align.csh and NMT_align.csh, scripts distributed
#  with the D99 macaque and the NMT macaque template datasets and tools

set progname = @animal_warper

# --------------------- version history with changes -----------------------
#
#set version = "1.00"
#
#set version = "1.02" ; set date = "Sep 3, 2019"
# [PT] Adding in @chauffeur_afni commands for visualization
#    + snapshots commented out
#    + cp -> \cp, etc.
#
#set version = "1.1" ; set date = "Sep 3, 2019"
# [PT] Make a "no skull" version of the orig dset
#    + another QC image: skull stripped area
#
#set version = "1.2" ; set date = "Sep 5, 2019"
# [PT] change smoothing of SUMA stuff, preserve ROIs more
#    + trivial stuff: change spacing / break lines for readability (sorry!)
#
#set version = "1.3" ; set date = "Sep 6, 2019"
# [PT] QC order rearranged a bit; change names; more useful focus (foci)
#    + QC to sep dir, called QC
#
#set version = "1.4" ; set date = "Sep 6, 2019"
# [PT] output dset that is wrpd2std, and skullstrip it with template
#      -> this is what would be useful to pass to AP
#
#set version = "1.5" ; set date = "Sep 10, 2019"
# [PT] unifize skullstripped template in standard template space
#    + describe QC images in help file, for reference
#    + remove __tmp* dset-- hadn't noticed COMPRESSOR was ON
#
#set version = "1.6" ; set date = "Sep 11, 2019"
# [DRG] remove temporary datasets with option to keep temporary datasets
#     + identify important output
#     + some help updates
#
#set version = "1.7" ; set date = "Sep 24, 2019"
# [DRG] fullpath for input datasets determined even if specified as ., .., ~
#
#set version = "1.71" ; set date = "Oct 3, 2019"
# [PT] Adjust 3dNotes to include @animal_warper name
#    + this goes with adjusting gen_ss_review_table.py so it recognizes
#      and reads in the template name
#    + make $animal_outs almost lined up?
#
set version = "1.72" ; set date = "Oct 7, 2019"
# [PT] $animal_outs descriptors more consistent
#    + add in prog version numbers to animal_outs scripts
#    + goes with change in afni.c to have simpler AFNI version 
#      number/package
#    + help now exits with 0
#
# --------------------------------------------------------------------
# --------------------------------------------------------------------


# [PT: Oct 7, 2019] changed condition from ("$#" < "2"), so that args
# get parsed and we can still get at script version number
if ("$#" <  "1") then
   goto HELP
endif

setenv AFNI_COMPRESSOR GZIP

set dset = ""
set base = ""
set segset = ""
set outdir = ""
set templatename = ""
set cost = ""
set maxlev = "11"
set make_orig_surfaces = "1"
set align_type = "all"
set ok_to_exist = "0"
set template_followers = ()
set seg_followers = ()
set feature_option = ""
set feature_size = ""
set supersize = ""
set keep_temp = ""
set animal_outs = "animal_outs.txt"

# process user options
set ac = 1
while ($ac <= $#argv)
    if ("$argv[$ac]" == "-help" || "$argv[$ac]" == "-h") then
        goto HELP
    else if ("$argv[$ac]" == "-ver") then
        echo $version
        exit 0
    else if ("$argv[$ac]" == "-input") then
        @ ac ++
        if ( $ac > $#argv ) then
            echo "** missing parameter for option '-dset'"
            exit 1
        endif
        set dset =  $argv[$ac]
    else if ("$argv[$ac]" == "-base") then
        @ ac ++
        if ( $ac > $#argv ) then
            echo "** missing parameter for option '-base'"
            exit 1
        endif
        set base =  $argv[$ac]
    else if ("$argv[$ac]" == "-atlas") then
        @ ac ++
        if ( $ac > $#argv ) then
            echo "** missing parameter for option '-atlas'"
            exit 1
        endif
        set segset =  $argv[$ac]
    else if ("$argv[$ac]" == "-outdir") then
        @ ac ++
        if ( $ac > $#argv ) then
            echo "** missing parameter for option '-outdir'"
            exit 1
        endif
        set outdir =  $argv[$ac]
    else if ("$argv[$ac]" == "-cost") then
        @ ac ++
        if ( $ac > $#argv ) then
            echo "** missing parameter for option '-cost'"
            exit 1
        endif
        set cost =  $argv[$ac]
    else if ("$argv[$ac]" == "-template_prefix") then
        @ ac ++
        if ( $ac > $#argv ) then
            echo "** missing parameter for option '-template_prefix'"
            exit 1
        endif
        set templatename =  $argv[$ac]
    else if ("$argv[$ac]" == "-maxlev") then
        @ ac ++
        if ( $ac > $#argv ) then
            echo "** missing parameter for option '-maxlev'"
            exit 1
        endif
        set maxlev =  $argv[$ac]
    else if ("$argv[$ac]" == "-align_type") then
        @ ac ++
        if ( $ac > $#argv ) then
            echo "** missing parameter for option '-align_type'"
            exit 1
        endif
        set align_type =  $argv[$ac]
        if (($align_type == "all") || ($align_type == "rigid") || \
         ($align_type == "rigid_equiv") || ($align_type == "affine")) then
           echo "align_type set to $align_type"
        else
           echo "align_type $align_type is not a valid choice"
           exit 1
        endif             
    else if ("$argv[$ac]" == "-ok_to_exist") then
        set ok_to_exist = "1"
    else if ("$argv[$ac]" == "-no_surfaces") then
        set make_orig_surfaces = "0"
    else if ("$argv[$ac]" == "-template_followers") then
        @ ac ++
        while ($ac <= $#argv)
            # go until an option starting with a hyphen appears
            set poss_dset = `echo $argv[$ac] | grep -- "^-"`
            # if the next argument starts with a hyphen
            # then the grep gives back the same argument
            # that means we're on to the next option
            # instead of a dataset
            if ("$argv[$ac]" == "$poss_dset") then
#               @ ac --               
               break
            # not a hyphen leading option, should be dataset 
            else
               set tempfollow = $argv[$ac] 
               # is the dataset somewhere else or current directory
               set tempfollow = `@FindAfniDsetPath -append_file \
                                    -full_path $tempfollow`
               # add the dataset to the template follower list
               set template_followers = ($template_followers $tempfollow)
            endif
            @ ac ++ 
        end
        if ( "$#template_followers" == "0" ) then
            echo "** missing dataset for option template_followers"
            exit 1
        endif
        @ ac --
    else if ("$argv[$ac]" == "-seg_followers") then
        @ ac ++
        while ($ac <= $#argv)
            # go until an option starting with a hyphen appears
            set poss_dset = `echo $argv[$ac] | grep -- "^-"`
            # if the next argument starts with a hyphen
            # then the grep gives back the same argument
            # that means we're on to the next option
            # instead of a dataset
            if ("$argv[$ac]" == "$poss_dset") then
#               @ ac --
               break
            # not a hyphen leading option, should be dataset 
            else
               set segfollow = $argv[$ac] 
               # is the dataset somewhere else or current directory
                set segfollow = `@FindAfniDsetPath -append_file \
                                    -full_path $segfollow`
               # add the dataset to the segmentation follower list
               set seg_followers = ($seg_followers $segfollow)
            endif
            @ ac ++ 
        end
        if ( $#seg_followers == 0 ) then
            echo "** missing dataset for option '-seg_followers'"
            exit 1
        endif
        @ ac --        

    else if ("$argv[$ac]" == "-feature_size") then
        @ ac ++
        if ( $ac > $#argv ) then
            echo "** missing parameter for option '-feature_size'"
            exit 1
        endif
        set feature_size = $argv[$ac]
        set feature_option =  "-feature size $feature_size"
    else if ("$argv[$ac]" == "-supersize") then
        set supersize = "-supersize"
    else if ("$argv[$ac]" == "-keep_temp") then
        set keep_temp = "1"
    else
        echo "** unknown option $argv[$ac]"
        exit 1
    endif        
    @ ac ++
end

# check for basic necessities
if ($dset == "") then
    echo "No input dataset provided"
    exit 1
endif

if ($base == "") then
    echo "No base template dataset provided"
    exit 1
endif

# put output in user specified name or default output directory
#  relative to current directoy
if ($outdir == "") then
   set outdir = "./template_align"
endif

if (($ok_to_exist == 1) && (-f ${outdir})) then
    echo "reusing ${outdir}"
else
   \mkdir -p $outdir
endif

# set costs for alignment
if ($cost == "") then
   set cost = "lpa+ZZ"
   set nlcost = ""
else
# nonlinear warps do not support +ZZ costs, so just use similar cost
   set nlcost = `basename $cost "+ZZ"`
endif

# allow for base to be in a standard directory or specified
#   expand @FindAfniDsetPath to allow for AFNI_SUPP_ATLAS_DIR
# is there a path in the name of the dataset
#set basedir = `dirname $base`
# is the dataset somewhere else or current directory
set base = `@FindAfniDsetPath -full_path -append_file $base`

if ($segset != "") then
   # is there a path in the name of the dataset
#   set segdir = `dirname $segset`
   # is the dataset somewhere else or current directory
   set segset = `@FindAfniDsetPath -full_path -append_file $segset`
endif

# get the non-NIFTI name out, dset+ , dset.nii, dset.nii.gz all -> 'dset'
set dsetprefix = `@GetAfniPrefix $dset`
echo $dsetprefix |grep '.gz$'
if ($status == "0") then
   set dsetext = ".gz"
else
   set dsetext = "" 
endif
set dsetprefix = `basename $dsetprefix .gz`
set dsetprefix = `basename $dsetprefix .nii`

# which afni view is used even if NIFTI dataset is used as base
# usually +tlrc
#set baseview = `3dinfo -av_space $base`

# input datasets may not be +orig
# so match input view equivalent even for NIFTI
set origview = `3dinfo -av_space $dset |tr -d +`
set origspace = `3dinfo -space $dset`


# if input dataset is NIFTI vs AFNI format
set dset_nifti = `3dinfo -is_nifti $dset`

# copy from AFNI format or from uncompressed data
if (($outdir != ".") || ($dset_nifti != "1") || ($dsetext == "")) then
   if (($ok_to_exist == 1) && (-f ${outdir}/${dsetprefix}.nii.gz)) then
      echo "reusing ${outdir}/${dsetprefix}.nii.gz"
   else
      3dcopy $dset ${outdir}/${dsetprefix}.nii.gz
   endif 
endif

if ($outdir != ".") then
   if (($ok_to_exist == 1) && (-f ${outdir}/`basename $base`)) then
      echo "reusing ${outdir}/$base"
   else
      3dcopy $base $outdir/
   endif
   
   if ($segset != "") then
      if (($ok_to_exist == 1) && (-f ${outdir}/`basename $segset`)) then
         echo "reusing ${outdir}/$segset"
      else
         3dcopy $segset $outdir/
      endif 
   endif
endif

cd $outdir

set dset = ${dsetprefix}.nii.gz
set finalmaster = $dset

set origdsetprefix = $dsetprefix

set afni_pack = `afni -package`
set afni_vnum = `afni -vnum`
set tbase     = `basename $base`

# set up output text file with file descriptions
echo "# List of inputs and outputs from @animal_warper" > ${animal_outs}
echo "AFNI package                 : $afni_pack"       >> ${animal_outs}
echo "AFNI version number          : $afni_vnum"       >> ${animal_outs}
echo "@animal_warper ver           : $version"         >> ${animal_outs}
echo ""                                                >> ${animal_outs}
echo "Input dset (orig)            : $dset"            >> ${animal_outs}
echo "Template dset (templ)        : $tbase"           >> ${animal_outs}
echo "Atlas/seg dset               : $segset"          >> ${animal_outs}
echo ""                                                >> ${animal_outs}

# figure out short name for template to insert into output files
if ($templatename == "") then
   echo $base |grep NMT
   if ($status == 0) then
      set templatename = "NMT"
   else
      echo $base |grep D99
      if ($status == 0) then
         set templatename = "D99"
      else
         set template_space = `3dinfo -space $base`
         if (($template_space != "ORIG") && ($template_space != "")) then
            set templatename = $template_space
         else
            set templatename = "template"
         endif
      endif
   endif
endif
  
if ($segset != "") then
   #set segsetprefix = `@GetAfniPrefix $segset`
   set segsetdir = `dirname $segset`
   # if a template prefix has been selected by user, use that
   # for segmentation name output too 
   if ($templatename != "") then
      set segname = "${templatename}_atlas"
   else
      echo $segset |grep D99
      if ($status == 0) then
         set segname = D99atlas
      else
         set segname = atlas
      endif
   endif
endif

# put the center of the dataset on top of the center of the template
if (($ok_to_exist == "1") && (-f  ${dsetprefix}_shft.nii.gz)) then
   echo "reusing center aligned  ${dsetprefix}_shft.nii.gz"
else 
   @Align_Centers -base $base -dset $dset -overwrite
endif

# keep a copy of the inverse translation too
# (should just be negation of translation column)
cat_matvec ${dsetprefix}_shft.1D -I > ${dsetprefix}_shft_inv.1D

set dset = ${dsetprefix}_shft.nii.gz
set dsetprefix = ${dsetprefix}_shft

echo "Dset, center-shifted to templ : $dset" >> ${animal_outs}

# goto apply_warps

if ($align_type == "rigid") then
   set rigidopt = "-rigid_body"
else
   set rigidopt = ""
endif

# do affine alignment with lpa cost
# using dset as dset2 input and the base as dset1
# (the base and source are treated differently
# by align_epi_anats resampling and by 3dAllineate)
if (($ok_to_exist == "1") && (-f  ${dsetprefix}_al2std_mat.aff12.1D)) then
   echo "reusing affine transformation matrix"
else 
   align_epi_anat.py -dset2 $dset -dset1 $base -overwrite -dset2to1 \
    -giant_move -suffix _al2std -dset1_strip None -dset2_strip None \
    -cost $cost $rigidopt $feature_option $supersize
    
   set baseview = `3dinfo -av_space $base` 
   # convert the affine aligned output to NIFTI
   3dAFNItoNIFTI -prefix ${dsetprefix}_al2std.nii.gz \
        ${dsetprefix}_al2std${baseview}
   \rm ${dsetprefix}_al2std${baseview}.*
endif

echo "Matrix, affine xform         : ${dsetprefix}_al2std_mat.aff12.1D" \
     >> ${animal_outs}
echo "Dset, aff-xformed to templ (orig res) : ${dsetprefix}_al2std.nii.gz" \
     >> ${animal_outs}

if ($align_type == rigid_equiv) then
    cat_matvec ${dsetprefix}_al2std_mat.aff12.1D -P \
        > ${dsetprefix}_al2std_mat_rigid.aff12.1D
    set affmat = ${dsetprefix}_al2std_mat_rigid.aff12.1D
    echo "Matrix, rigid equiv xform    : $affmat" >> ${animal_outs}
else
    set affmat = ${dsetprefix}_al2std_mat.aff12.1D
endif

## put affine aligned data on template grid
# similar to al2std dataset but with exactly same grid as the template
if (($ok_to_exist == "1") && (-f ${dsetprefix}_aff.nii.gz)) then
   echo "reusing affine transformed dataset"
else 
   3dAllineate -1Dmatrix_apply $affmat                                 \
        -prefix ${dsetprefix}_aff.nii.gz -base $base -master BASE      \
        -source $dset -overwrite
endif
echo "Dset, aff-xformed to templ   : ${dsetprefix}_aff.nii.gz" \
     >> ${animal_outs}

# if nonlinear alignment is not requested, then exit
if ( $align_type != "all" ) then
   echo "Finished aligning with only $align_type alignment"
   if ($align_type == "rigid") then
      echo "This alignment method requires restarting the alignment"
      echo "for other types of alignment"
   else
      echo "You may restart for other types of alignment with"
      echo "a different align_type and -ok_to_exist"
   endif
      goto FINISH_OUTS

endif

# affinely align to template
#  (could let auto_warp.py hande this, but AUTO_CENTER option might be needed)
# @auto_tlrc -base $base -input $dset -no_ss -init_xform AUTO_CENTER

# !!! Now skipping cheap skullstripping !!!  didn't work for macaques
#   with very different size brains. V1 got cut off probably could
#   work with dilated mask "cheap" skullstripping with affine
#   registered dataset the macaque brains are similar enough that the
#   affine seems to be sufficient here for skullstripping
# 3dcalc -a ${dsetprefix}_aff+tlrc. -b $base -expr 'a*step(b)'   \
#    -prefix ${dsetprefix}_aff_ns -overwrite

# nonlinear alignment of affine skullstripped dataset to template
#  by default,the warp and the warped dataset are computed
#  by using "-qw_opts ", one could save the inverse warp and do extra padding
#  with -qw_opts '-iwarp -expad 30'
# change qw_opts to remove max_lev 2 for final   ********************

\rm -rf awpy_${dsetprefix}

# user set cost function
if ($nlcost != "") then
    set nlcostoption = "-$nlcost"
else
    # using default cost in 3dQwarp
    set nlcostoption = ""
endif

if (($ok_to_exist == "1") && (-f ${dsetprefix}_WARP.nii.gz)) then
   echo "reusing nonlinear WARP dataset"
else 
   # nonlinear warping via auto_warp script
   auto_warp.py -base $base -affine_input_xmat ID -qworkhard 0 2 \
      -input ${dsetprefix}_aff.nii.gz -overwrite                 \
      -output_dir awpy_${dsetprefix} -qw_opts -iwarp             \
      -maxlev $maxlev $nlcostoption
   
   # the awpy has the result dataset, copy the warped data, the warp,
   # inverse warp don't copy the warped dataset - combine the
   # transformations instead below
   # cp awpy_${dsetprefix}/${dsetprefix}_aff.aw.nii ./${dsetprefix}_warp2std.nii

   3dcopy -overwrite \
        awpy_${dsetprefix}/anat.*.qw_WARP.nii* \
        ${dsetprefix}_WARP.nii.gz

   3dcopy -overwrite \
        awpy_${dsetprefix}/anat.*.qw_WARPINV.nii* \
        ${dsetprefix}_WARPINV.nii.gz

endif

echo "NL warp to templ             : ${dsetprefix}_WARP.nii.gz"    \
     >> ${animal_outs}
echo "NL inv-warp from templ       : ${dsetprefix}_WARPINV.nii.gz" \
     >> ${animal_outs}

#apply_warps:

# Make subdirectory for QC images
\mkdir -p QC

if ( ($ok_to_exist == "1") &&                  \
     (-f ${origdsetprefix}_warp2std.nii.gz) && \
     (-f ${origdsetprefix}_warp2std_nsu.nii.gz) ) then
   echo "reusing nonlinear transformed dataset"
else 
   # combine nonlinear and affine warps for dataset warped to standard
   # template space **** mod - DRG 07 Nov 2016
   3dNwarpApply -prefix ${origdsetprefix}_warp2std.nii.gz                  \
      -nwarp "${dsetprefix}_WARP.nii.gz ${dsetprefix}_al2std_mat.aff12.1D" \
      -source $dset -master $base  -overwrite

   # make masked version of orig dset in template space, using the template
   # itself.
   3dcalc -overwrite                               \
      -a "${origdsetprefix}_warp2std.nii.gz"       \
      -b "$base"                                   \
      -expr 'a*step(b)'                            \
      -prefix ${origdsetprefix}_warp2std_ns.nii.gz

   # nicer version for viewing in template space: this will be passed
   # along to AP to be ulay at times
   echo "unifizing anatomical dset in template space"
   3dUnifize                                        \
      -overwrite                                    \
      -input  ${origdsetprefix}_warp2std_ns.nii.gz  \
      -prefix ${origdsetprefix}_warp2std_nsu.nii.gz

   # ... and put a note in its history, so that
   # gen_ss_review_scripts.py knows the name of the template
   set tbase = `basename $base`
   3dNotes \
      -h "@animal_warper aligned this dset to standard space: -base $base" \
      ${origdsetprefix}_warp2std_nsu.nii.gz


   # Image   : [ulay] edges of template; [olay] orig dset, warped to template
   # This is in template space, so use the template (which has no skull)
   # as a refbox
   set ulay  = "$base"
   set olay  = "${origdsetprefix}_warp2std.nii.gz"
   set opref = QC/qc_00_e_temp+wrpd_inp

   @chauffeur_afni                            \
       -ulay "${ulay}"                        \
       -edgy_ulay                             \
       -ulay_range_nz 0% 30%                  \
       -set_subbricks 0 0 0                   \
       -olay "${olay}"                        \
       -box_focus_slices AMASK_FOCUS_ULAY     \
       -cbar Spectrum:red_to_blue             \
       -func_range_perc_nz 95                 \
       -montgap 1                             \
       -montcolor 'black'                     \
       -pbar_posonly                          \
       -pbar_saveim ${opref}                  \
       -prefix      ${opref}                  \
       -opacity 4                             \
       -montx 5 -monty 3                      \
       -set_xhairs OFF                        \
       -label_mode 1 -label_size 3 

endif

# maybe change names? these sound like warp dsets, but they are
# actually dsets that *have* been warped
echo "Dset, NL-warped to templ     : ${origdsetprefix}_warp2std.nii.gz" \
       >> ${animal_outs}
echo "Dset, NL-warped to templ (no skull) : ${origdsetprefix}_warp2std_ns.nii.gz" \
      >> ${animal_outs}
echo "Dset, NL-warped to templ (no skull, uni) : ${origdsetprefix}_warp2std_nsu.nii.gz" \
      >> ${animal_outs}
echo "QC directory of images       : QC/" >> ${animal_outs} 

# compute the inverse of the affine alignment transformation - all 12 numbers
#cat_matvec ${dsetprefix}_al2std_mat.aff12.1D \
#     >! ${dsetprefix}_al2std_mat.aff12.1D
cat_matvec -ONELINE                             \
    ${dsetprefix}_al2std_mat.aff12.1D -I        \
    >! ${dsetprefix}_inv_al2std_mat.aff12.1D

# combine shft and affine 1D files for composite linear transformation
# to template space combining shift is dangerous! The transformation
# distance can be very large, and 3dNwarpApply will create a high
# resolution space that will likely eat up large amounts of memory
# ****USE WITH CAUTION *******
cat_matvec -ONELINE ${dsetprefix}.1D ${dsetprefix}_al2std_mat.aff12.1D > \
     ${origdsetprefix}_composite_linear_to_template.1D
#Now create the inverse composite warp from template to subject space
cat_matvec -ONELINE ${dsetprefix}_inv.1D        \
    ${dsetprefix}_inv_al2std_mat.aff12.1D       \
    > ${origdsetprefix}_composite_linear_to_template_inv.1D

# use concatenated affine and nonlinear warp to go back to shifted
# original space
if ( ($ok_to_exist == "1") && \
     (-f  ${templatename}_in_${origdsetprefix}.nii.gz) ) then
   echo "reusing template transformed to native space dataset"
else 
   3dNwarpApply -overwrite -nwarp \
     "${dsetprefix}_inv_al2std_mat.aff12.1D ${dsetprefix}_WARPINV.nii.gz)" \
      -source $base -master ${dsetprefix}.nii.gz                           \
      -prefix ${templatename}_in_${origdsetprefix}.nii.gz
   
   # put back in non-shifted version (really native space) 
   @Align_Centers -base ${finalmaster} \
        -dset ${templatename}_in_${origdsetprefix}.nii.gz -no_cp

   # put back into the view of the original dataset to make it viewable in AFNI
#   gunzip -f ${templatename}_in_${origdsetprefix}.nii.gz
#   nifti_tool -mod_hdr -mod_field sform_code $origsform_code \
#              -mod_field qform_code $origqform_code -overwrite \
#              -infiles ${templatename}_in_${origdsetprefix}.nii
#   gzip -f ${templatename}_in_${origdsetprefix}.nii
   3drefit -space $origspace  ${templatename}_in_${origdsetprefix}.nii.gz 

   # image is taken below, after skull-stripping applied to make focus
   # mask...

endif

if ( ($ok_to_exist == "1") &&              \
     (-f  ${origdsetprefix}_ns.nii.gz) &&  \
     (-f  ${origdsetprefix}_mask.nii.gz) ) then
   echo "reusing masked original dset"
else 
   3dcalc \
      -a ${templatename}_in_${origdsetprefix}.nii.gz   \
      -b ${origdsetprefix}.nii.gz                      \
      -expr 'step(a)*b'                                \
      -prefix __tmp_orig_mskd.nii.gz                   \
      -overwrite 

   # smoothify mask with in/out dilations; slightly pad: this is our
   # new anat mask.
   3dmask_tool                                \
      -dilate_inputs -2 3                     \
      -inputs __tmp_orig_mskd.nii.gz          \
      -prefix ${origdsetprefix}_mask.nii.gz   \
      -overwrite

   3dcalc \
      -a ${origdsetprefix}.nii.gz             \
      -b ${origdsetprefix}_mask.nii.gz        \
      -expr 'a*step(b)'                       \
      -prefix ${origdsetprefix}_ns.nii.gz     \
      -overwrite
    
   # Image   : [ulay] edges of warped template; [olay] orig dset
   set ulay  = "${templatename}_in_${origdsetprefix}.nii.gz"
   set olay  = "${origdsetprefix}.nii.gz"
   set focus = "${origdsetprefix}_mask.nii.gz"
   set opref = QC/qc_01_e_wrpd_temp+orig_inp

   @chauffeur_afni                            \
       -ulay "${ulay}"                        \
       -edgy_ulay                             \
       -ulay_range_nz 0% 30%                  \
       -set_subbricks 0 0 0                   \
       -olay "${olay}"                        \
       -box_focus_slices "${focus}"           \
       -cbar Spectrum:red_to_blue             \
       -func_range_perc_nz 95                 \
       -montgap 1                             \
       -montcolor 'black'                     \
       -pbar_posonly                          \
       -pbar_saveim ${opref}                  \
       -prefix      ${opref}                  \
       -opacity 4                             \
       -montx 5 -monty 3                      \
       -set_xhairs OFF                        \
       -label_mode 1 -label_size 3 

   # Image   : [ulay] orig dset [olay] mask of orig dset
   set ulay  = ${origdsetprefix}.nii.gz
   set olay  = ${origdsetprefix}_mask.nii.gz
   set focus = ${olay}
   set opref = QC/qc_02_orig_inp+mask

   @chauffeur_afni                            \
       -ulay "${ulay}"                        \
       -ulay_range_nz 0% 98%                  \
       -set_subbricks 0 0 0                   \
       -olay "${olay}"                        \
       -box_focus_slices "${focus}"           \
       -cbar RedBlueGreen                     \
       -montgap 1                             \
       -montcolor 'black'                     \
       -pbar_posonly                          \
       -pbar_saveim ${opref}                  \
       -prefix      ${opref}                  \
       -opacity 3                             \
       -montx 5 -monty 3                      \
       -set_xhairs OFF                        \
       -label_mode 1 -label_size 3 

   # clean up a bit
   \rm -f __tmp_orig_mskd.nii.gz 

endif

# process any template followers the same way
foreach temple_dset ($template_followers)
   set temple_prefix = `@GetAfniPrefix $temple_dset`
   set temple_prefix = `basename $temple_prefix .gz`
   set temple_prefix = `basename $temple_prefix .nii`

   if ( ($ok_to_exist == "1") && \
        (-f  ${temple_prefix}_in_${origdsetprefix}.nii.gz) ) then
      echo "reusing template transformed to native space dataset"
   else 
      3dNwarpApply -overwrite -short -nwarp \
        "${dsetprefix}_inv_al2std_mat.aff12.1D ${dsetprefix}_WARPINV.nii.gz)" \
         -source $temple_dset -master ${dsetprefix}.nii.gz \
         -prefix ${temple_prefix}_in_${origdsetprefix}.nii.gz
      
      # put back in non-shifted version (really native space) 
      @Align_Centers -base ${finalmaster} \
            -dset  ${temple_prefix}_in_${origdsetprefix}.nii.gz -no_cp
      # put back into the view of the original dataset to make it
      # viewable in AFNI
      #gunzip -f ${temple_prefix}_in_${origdsetprefix}.nii.gz
      #nifti_tool -mod_hdr -mod_field sform_code $origsform_code \
                 #-mod_field qform_code $origqform_code -overwrite \
                 #-infiles ${temple_prefix}_in_${origdsetprefix}.nii
      #gzip -f ${temple_prefix}_in_${origdsetprefix}.nii
      3drefit -space $origspace ${temple_prefix}_in_${origdsetprefix}.nii.gz
  endif
    echo "Templ, NL-warped to orig : ${temple_prefix}_in_${origdsetprefix}.nii.gz" >> ${animal_outs}

end

 # warp segmentation from atlas back to the original macaque space
 #  of the input dataset (compose overall warp when applying)
 #  note - if transforming other datasets like the template
 #    back to the same native space, it will be faster to compose
 #    the warp separately with 3dNwarpCat or 3dNwarpCalc rather
 #    than composing it for each 3dNwarpApply
 if ($segset != "") then
    # this only warps back to the affine warped space (~ in template space)  
#    3dNwarpApply -ainterp NN -short -overwrite -nwarp \
#       ${dsetprefix}_WARPINV.nii.gz  -overwrite \
#       -source $segset -master ${dsetprefix}_aff.nii.gz \
#       -prefix ${segname}_in_${origdsetprefix}.nii.gz
    # moves data to orig space - but introduces second interpolation
    # on nearest neighbor ROI data, this can make for odd artifacts
#    3dAllineate -source ${segname}_in_${origdsetprefix}.nii.gz \
#        -base ${origdsetprefix}.nii.gz \
#    	-final NN \
#        -1Dmatrix_apply ${origdsetprefix}_composite_linear_to_template_inv.1D \
#        -prefix ${segname}_in_${origdsetprefix}.nii.gz
    # deletes the segmentation in affine warped space
    
    foreach segm_dset ($segset $seg_followers)     
       if ($segm_dset == $segset) then
          set seg_prefix = $segname
       else
          set seg_prefix = `@GetAfniPrefix $segm_dset`
          set seg_prefix = `basename $seg_prefix .gz`
          set seg_prefix = `basename $seg_prefix .nii`
       endif
       
       if ( ($ok_to_exist == "1") && \
            (-f  ${seg_prefix}_in_${origdsetprefix}.nii.gz) ) then
          echo "reusing segmentation transformed to native space dataset"
       else 
          \rm ${seg_prefix}_in_${origdsetprefix}.nii.gz
   
           # use concatenated affine and nonlinear warp to go back to
           # shifted original space
           3dNwarpApply -ainterp NN -short -overwrite -nwarp \
             "${dsetprefix}_inv_al2std_mat.aff12.1D ${dsetprefix}_WARPINV.nii.gz)" \
              -source $segm_dset -master ${dsetprefix}.nii.gz \
              -prefix ${seg_prefix}_in_${origdsetprefix}.nii.gz
       
           # put back in non-shifted version (really native space) 
           @Align_Centers -base ${finalmaster} \
                -dset  ${seg_prefix}_in_${origdsetprefix}.nii.gz -no_cp
       
           # change the datum type to byte to save space if values
           # range from 0 to 255 this step also gets removes the shift
           # transform information in the header overwriting original
           # dataset just created
           set segminmax = `3dBrickStat -min -max -slow \
                                ${seg_prefix}_in_${origdsetprefix}.nii.gz`
           if (($segminmax[2] <= 255) && ($segminmax[1] >= 0)) then
              3dcalc \
                -a ${seg_prefix}_in_${origdsetprefix}.nii.gz \
                -expr a -datum byte -nscale                  \
              -overwrite -prefix ${seg_prefix}_in_${origdsetprefix}.nii.gz
           endif
           
           # copy segmentation information from atlas to this native-space
           #   segmentation dataset and mark to be shown with integer colormap
           #gunzip -f ${seg_prefix}_in_${origdsetprefix}.nii.gz
           #nifti_tool -mod_hdr -mod_field sform_code $origsform_code \
                 #-mod_field qform_code $origqform_code -overwrite \
                 #-infiles ${seg_prefix}_in_${origdsetprefix}.nii
           #gzip -f ${seg_prefix}_in_${origdsetprefix}.nii
           3drefit -cmap INT_CMAP -space \
                $origspace ${seg_prefix}_in_${origdsetprefix}.nii.gz
           3drefit -copytables $segm_dset \
                ${seg_prefix}_in_${origdsetprefix}.nii.gz

           # Image : [ulay] edge enhanced orig dset; 
           #         [olay] atlas warped to orig space
           set ulay  = "${origdsetprefix}.nii.gz"
           set olay  = "${seg_prefix}_in_${origdsetprefix}.nii.gz"
           set focus = ${origdsetprefix}_mask.nii.gz
           set opref = QC/qc_03_ee_orig_inp+wrpd_atlas
                    
           @chauffeur_afni                             \
                -ulay "${ulay}"                        \
                -edge_enhance_ulay 0.5                 \
                -set_subbricks 0 0 0                   \
                -olay "${olay}"                        \
                -box_focus_slices "${focus}"           \
                -montgap 1                             \
                -montcolor 'black'                     \
                -cbar ROI_i256                         \
                -pbar_posonly                          \
                -pbar_saveim "${opref}"                \
                -prefix      "${opref}"                \
                -opacity 4                             \
                -montx 5 -monty 3                      \
                -set_xhairs OFF                        \
                -label_mode 1 -label_size 3 

           #mv ${segsetdir}/${segname}_in_${origdsetprefix}.nii.gz \
           #     ./${segname}_in_${origdsetprefix}.nii.gz
       endif
    echo "Atlas/seg, NL-warped to orig : ${seg_prefix}_in_${origdsetprefix}.nii.gz"\
            >> ${animal_outs}
    end 
    
          
    # create surfaces for template and all individual regions in
    # atlas, but now in native space
    if ($make_orig_surfaces == "1") then
       # "carve" out template surface in native space instead to use
       #  as representative surface using anisotropic smoothing could
       #  use skullstripped original instead
       if ( ($ok_to_exist == "1") && \
            (-f  ${templatename}_in_${origdsetprefix}_aniso.nii.gz ) ) then
          echo "reusing anisotropically smoothed template"
          echo "  in native space dataset"
       else 
          3danisosmooth \
            -prefix ${templatename}_in_${origdsetprefix}_aniso.nii.gz \
            -automask -3D -iters 6 -matchorig                         \
            ${templatename}_in_${origdsetprefix}.nii.gz
       endif
       # also remove any  small clusters for surface generation 
       #  (threshold here is specific so may need tweaking)
       set baseperc = 15
       set basestats = `3dBrickStat -percentile $baseperc 1 $baseperc \
                            -non-zero \
                            ${templatename}_in_${origdsetprefix}_aniso.nii.gz`
       # non-zero count not right with percentile, so doing it separately here
       set basestats2 = `3dBrickStat -max -count -non-zero \
           ${templatename}_in_${origdsetprefix}_aniso.nii.gz`
       set basethresh = $basestats[2] 
       set basemax = $basestats2[1]
       set minbrainvolume  = `ccalc -int "$basestats2[2]*0.5"`
       
       if ( ($ok_to_exist == "1") && \
            (-f  ${templatename}_in_${origdsetprefix}_aniso_clust.nii.gz )) then
          echo "reusing anisotropically smoothed and clustered template"
          echo "  in native space dataset"
       else 
          3dClusterize -idat 0 -ithr 0 -1sided RIGHT_TAIL $basethresh \
             -pref_dat ${templatename}_in_${origdsetprefix}_aniso_clust.nii.gz \
             -inset  ${templatename}_in_${origdsetprefix}_aniso.nii.gz -NN 2 \
             -clust_nvox  $minbrainvolume
       endif

       if ( ($ok_to_exist == "1") && \
            (-f  ${templatename}_in_${origdsetprefix}.gii ) ) then
          echo "reusing template in native space surface dataset"
       else 
          IsoSurface -isorange $basethresh $basemax -overwrite \
            -input  ${templatename}_in_${origdsetprefix}_aniso_clust.nii.gz \
            -o  ${templatename}_in_${origdsetprefix}.gii -overwrite \
            -noxform -Tsmooth 0.01 6 
       endif
          echo "Templ surf in orig           : ${templatename}_in_${origdsetprefix}.gii" \
            >> ${animal_outs}

#       if (($ok_to_exist == "1") && (-f  surfaces/native*.gii )) then
#          echo "reusing segmentation surfaces in native space"
#       else 
           if (-f ${segname}_in_${origdsetprefix}.nii.gz) then
              \rm -rf surfaces/        
              \mkdir surfaces
              cd surfaces
              IsoSurface -isorois+dsets -o native.gii \
                -input ../${segname}_in_${origdsetprefix}.nii.gz -noxform \
                -Tsmooth 0.01 6 
              cd ..
           endif
#       endif
            echo "Atlas/seg surfs in orig      : ./surfaces" \
                >> ${animal_outs}
    endif

 endif


# get rid of temporary warped datasets
if($keep_temp != "1") then
   \rm -rf "awpy_${dsetprefix}/"
   \rm -f "__tmp*_${dsetprefix}*.HEAD __tmp*_${dsetprefix}*.BRIK*"
   \rm -f "__tmp*_${dsetprefix}*.nii*"
   \rm -f "__tmp*_${dsetprefix}*.1D"
   \rm -f "${templatename}_in_${origdsetprefix}_aniso*.nii.gz"
endif

# finish outputs and exit gracefully: normal exit for default proc
goto FINISH_OUTS

# -------------------------------------------

# notes

# warp the transformed macaque back to its original space
#  just as a quality control. The two datasets should be very similar
#3dNwarpApply -overwrite -short -nwarp \
#   "${dsetprefix}_inv.aff12.1D INV(${dsetprefix}_WARP.nii.gz)" \
#   -source ${dsetprefix}_warp2std.nii.gz -master ${finalmaster}${origview} \
#   -prefix ${dsetprefix}_iwarpback -overwrite


# zeropad the warp if segmentation doesn't cover the brain and reapply the warp
# 3dZeropad -S 50 -prefix ${dsetprefix}_zp_WARP.nii.gz ${dsetprefix}_WARP.nii.gz
# 3dNwarpApply -interp NN \
#   -nwarp "${dsetprefix}_inv.aff12.1D INV(${dsetprefix}_zp_WARP.nii.gz)" \
#   -source $segset -master $dset -prefix ${dsetprefix}_seg_zp
# 3drefit -cmap INT_CMAP ${dsetprefix}_seg_zp${origview}
# 3drefit -copytables $segset ${dsetprefix}_seg_zp${origview}

HELP:

cat << SCRIPT_HELP_STRING

Overview ~1~

Script to align a subject structural data to a template and invert the
warps to compute the template and segmentation in the subject's
original, native space.

This program uses basic AFNI commands to compute affine and nonlinear
alignments. The program works by first aligning centers of the subject
to that of the template. Affine and nonlinear alignment follow. The 
inverse warp is computed to bring the template and atlas segmentation
into the center-shifted grid. Skullstripping is provided by masking 
with the template. Finally, the grids are adjusted back to the
original center. Surfaces are made for all the atlas regions and for
a transformed copy of the template dataset.

Usage Example ~1~

    tcsh @animal_warper -input macaque1+orig        \
      -base ../NMT.nii.gz                           \
      -atlas atlas_dir/D99_atlas_1.2a_al2NMT.nii.gz \
      -outdir aligned_data
   
   Note only the input dset and template_dset are required. If no
   segmentation is given, then only the alignment steps are performed.

Options ~1~

    -input dset         :required input dataset to align to template

    -base  base_dataset :required template. Can be in a standard AFNI 
                         location or fully specified path. 
                         Note, if the template has no skull, then a
                         masked (skullstripped) version of the input
                         is produced in the output

    -atlas atlas_dataset :atlas can also be in a standard AFNI location 
                         or fully specified

    -outdir outputdir   :create new directory and do all processing there.
                         Default is template_align

    -template_prefix templatename 
                        :select name for template and segmentation
                         output Defaults to D99, NMT or template for
                         template output and D99 or atlas for
                         segmentation output.  Uses template space of
                         template if available in template header

    -cost xxx           :choose a cost function for affine and nonlinear
                         alignment. The same or similar cost function will
                         be used for both alignments. The cost functions
                         are listed in the help for 3dAllineate and 3dQwarp.
                         Cost functions, like lpa+ZZ for 3dAllineate, are
                         not available in 3dQwarp, so the "+ZZ" part is
                         removed, and lpa would be used in that case for
                         3dQwarp's nonlinear warping cost function. The
                         default cost function is lpa+ZZ for affine
                         warping (via align_epi_anat.py and 3dAllineate)
                         and a clipped Pearson correlation for nonlinear
                         warping (via auto_warp.py and 3dQwarp)

    -template_followers dset1 dset2 ...
                        :warp related datasets back to native space

    -seg_followers segdset1 segdset2 ...
                        :warp related datasets back to native space
                         
    -maxlev nn          :maximum level for nonlinear warping. Determines
                         neighborhood size that is searched. See 3dQwarp
                         help for information on maxlev. Default is 11.
                         Use smaller values for testing

    -no_surfaces        :do not make surfaces for atlas regions in native
                         space. Default is to create a surface directory
                         with surfaces of each region in native space

    -align_type         :provide alignment only to specified level
                         (rigid,rigid_equiv,affine,all)
                         rigid - align using rotation and translation
                         rigid_equiv - compute alignment with full affine
                            but apply only the rigid parameters.
                            This is usually preferred over the rigid body
                            alignment because it handles different sizes
                            better. The purpose here is to put data into
                            approximately the same position as the template
                            (AC-PC, axialized, ...)
                         affine - full affine, 12 parameters
                            rotation, translation, shearing and scaling
                         all - go through affine and nonlinear warps (Default)
                         Note, any option other than all will forego the
                         reverse warps for now. You may restart and reuse
                         existing warp transformations with the -ok_to_exist
                         option

    -feature_size mm    :set size in mm for affine alignment. Use about 0.1
                         for mouse, 0.5 for rat

    -supersize          :allow for up to 50% size difference between subject
                         and template

    -keep_temp          :keep temporary files including awpy directory and 
                         other intermediate datasets

    -ok_to_exist        :reuse and do not overwrite existing datasets.
                         This option is used for faster restarts or with
                         limited alignment options 

Comments ~1~

    @animal_warper provides multiple outputs to assist in registering your
    anatomicals and associated MRI data to the template:

    Subject scans registered to the template
   	+ mydset_shft.nii.gz - dataset center aligned to the template center
   	+ mydset_shft_al2std.nii.gz - dataset affine aligned to the template
   	+ mydset_shft_aff.nii.gz - dataset affine aligned to the template
                                   and on the template grid
   	+ mydset_warp2std.nii.gz - dataset nonlinearly warped to the template

    Registration datasets for alignment to template
   	+ mydset_composite_linear_to_template.1D** - combined affine 
                               transformations to the template
   	+ mydset_shft_WARP.nii.gz - warp deformations to the template from
                                nonlinear alignment only

    Registration datasets for Template alignment to Subject
   	+ mydset_composite_linear_to_template_inv.1D** - inverse of 
                              mydset_composite_linear_to_template.1D
   	+ mydset_shft_WARPINV.nii.gz - inverse of mydset_shft_WARP.nii.gz

    Atlas aligned to Subject (Optional - only if atlas provided)
   	+ seg_in_mydset.nii.gz - atlas segmentation aligned to native scan

    Template aligned_to Subject
    + template_in_mydset.nii.gz** - template (e.g. NMT,D99) aligned 
      to native scan

    Text description of output
    + animal_outs.txt - list of important datasets and transforms in
                        output directory
     
    ***-NOTE: @animal_warper is part of the AFNI software package  ***
    Here all occurrences of mydset in the output file names would be replaced
       with the name of your dataset. For NMT and D99 templates, the output
       will contain NMT or D99 instead of template


QC images ~1~

The following quality control (QC) images are automatically generated
during processing, to help with speedy checking of processing.  In
each case, there are three sets of montages (one for sag, cor and axi
views) and a copy of the colorbar used (same prefix as file name,
*.jpg).  Additionally, there is also a *.txt file of ranges of values
related to the ulay and olay, which might be useful for QC or
figure-generation.

Inside the output directory is a subdirectory called QC/ that contains
the following semi-cryptically named files:

  qc_00_e_temp+wrpd_inp.* 
    [ulay] edges of the template (in template space)
    [olay] warped input dset

  qc_01_e_wrpd_temp+orig_inp.*
    [ulay] edges of the template (warped to orig space)
    [olay] original input dset 

  qc_02_orig_inp+mask.*
    [ulay] original input dset (in orig space)
    [olay] estimated mask, showing skullstripping

  qc_03_ee_orig_inp+wrpd_atlas.*
    [ulay] 'edge enhanced' original input dset (in orig space)
    [olay] warped atlas dset


References ~1~

This script is derived from macaque_align.csh and NMT_subject_align.csh,
 scripts distributed with the D99 macaque and the NMT macaque template
 datasets and tools
SCRIPT_HELP_STRING

   exit 0

# ---------------------------------------

FINISH_OUTS:

echo "List of outputs (this file)  : ${animal_outs}" >> ${animal_outs}
echo ""                                              >> ${animal_outs}
echo "# Command  :  $argv"                           >> ${animal_outs}

echo "Highlights of the output:"
# show list of outputs
cat ${animal_outs}
  
exit 0
