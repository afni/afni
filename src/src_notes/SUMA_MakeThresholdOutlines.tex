\documentclass[twoside,onecolumn]{article}

\usepackage{blindtext} % Package to generate dummy text throughout this template 

\usepackage[sc]{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics

\usepackage[english]{babel} % Language hyphenation and typographical rules

\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry} % Document margins
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions under/above floats in tables or figures
\usepackage{booktabs} % Horizontal rules in tables

\usepackage{lettrine} % The lettrine is the first enlarged letter at the beginning of the text

\usepackage{graphicx}

\usepackage{enumitem} % Customized lists
\setlist[itemize]{noitemsep} % Make itemize lists more compact

\usepackage{abstract} % Allows abstract customization
\renewcommand{\abstractnamefont}{\normalfont\bfseries} % Set the "Abstract" text to bold
\renewcommand{\abstracttextfont}{\normalfont\small\itshape} % Set the abstract itself to small italic text

\usepackage{titlesec} % Allows customization of titles
\renewcommand\thesection{\Roman{section}} % Roman numerals for the sections
\renewcommand\thesubsection{\roman{subsection}} % roman numerals for subsections
\titleformat{\section}[block]{\large\scshape\centering}{\thesection.}{1em}{} % Change the look of the section titles
\titleformat{\subsection}[block]{\large}{\thesubsection.}{1em}{} % Change the look of the section titles

\usepackage{fancyhdr} % Headers and footers
\pagestyle{fancy} % All pages have headers and footers
\fancyhead{} % Blank out the default header
\fancyfoot{} % Blank out the default footer
\fancyhead[C]{Running title $\bullet$ May 2016 $\bullet$ Vol. XXI, No. 1} % Custom header text
\fancyfoot[RO,LE]{\thepage} % Custom footer text

\usepackage{enumitem}
%\usepackage{paralist}
%\setlistdepth{20}
%\renewlist{compactitem}{itemize}{20}
%\setlist[compactitem]{label=$\cdot$}
%
%% Redefine bullet symbols for nested lists
%\renewcommand{\labelitemi}{$\bullet$}       % level 1
%\renewcommand{\labelitemii}{$\circ$}        % level 2
%\renewcommand{\labelitemiii}{$\triangleright$} % level 3
%\renewcommand{\labelitemiv}{$\diamond$}     % level 4

\usepackage{enumitem}

% Define bullet styles per level (add more if needed)
\setlist[itemize,1]{label=$\bullet$}
\setlist[itemize,2]{label=$\circ$}
\setlist[itemize,3]{label=$\triangleright$}
\setlist[itemize,4]{label=$\diamond$}
\setlist[itemize,5]{label=$\star$}
\setlist[itemize,6]{label=$\cdot$}  % add more levels as needed
\setlist[itemize,7]{label=$-$}
\setlist[itemize,8]{label=$\ast$}
\setlist[itemize,9]{label=$rhd$}
\setlist[itemize,10]{label=$lhd$}
\setlist[itemize,11]{label=$\bigtriangleup$}
\setlist[itemize,12]{label=$bigtriangledown$}
\setlist[itemize,13]{label=$triangleleft$}
\setlist[itemize,14]{label=$triangleright$}
\setlist[itemize,15]{label=$unlhd$}
\setlist[itemize,16]{label=$unrhd$}
\setlist[itemize,17]{label=$oplus$}
\setlist[itemize,18]{label=$ominus$}
\setlist[itemize,19]{label=$otimes$}
\setlist[itemize,20]{label=$oslash$}
\setlist[itemize,21]{label=$obigcirc$}
\setlist[itemize,22]{label=$dagger$}
\setlist[itemize,23]{label=$ddagger$}
\setlist[itemize,24]{label=$cap$}
\setlist[itemize,25]{label=$cup$}


\usepackage{amsmath}

\begin{document}

\section*{SUMA\_MakeThresholdOutlines}

\begin{itemize}
	\item \texttt{ado = SUMA\_Overlay\_OwnerADO(Sover);}
	\item \texttt{SO = (SUMA\_SurfaceObject *)ado;}
	\item Check that required pointers are not \texttt{NULL}
	
	\item \texttt{SUMA\_Find\_ColorMap}
	\begin{itemize}
		\item Ensure that color maps exist; if not, exit.
		\item Cycle through maps to find the required map.
		\item If found, return the map; otherwise return failure.
	\end{itemize}
	
	\item If colormap not found, return with an error message.
	\item Create a scaled color vector.
	
	\item If show mode is \texttt{Con} or \texttt{CaC}:
	\begin{itemize}
		\item \texttt{return = SUMA\_NeedsLinearizing(ColMap)}
		\begin{itemize}
			\item If there is no $N_{\text{col}} \times 1$ vector containing the fraction of scale assigned to each color
			(values shown on the right of the colorbar in AFNI), return 0.
			\item If the number of colors in the colormap $\times$ the number of columns in $M$
			(where $M$ is an $N_{\text{col}} \times 3$ matrix of RGB values in $[0,1]$), return 0.
			\item If there is a hot spot in the color vector, return 1; otherwise return 0.
		\end{itemize}
	\end{itemize}
	
	\item Else, set \texttt{ColsContMode = 0}.
	
	\item Create color scale vector:
	\begin{itemize}
		\item Allocate memory for the color scale vector.
		\item Allocate memory for its \texttt{cv} and \texttt{isMasked} components for the number of nodes.
		The \texttt{BiasCoordVec} component is set to \texttt{NULL} until it is determined whether it is needed.
		\item If \texttt{ColsContMode}, allocate \texttt{vCont} for the number of nodes.
		\item If allocation of \texttt{cv} or \texttt{isMasked} fails, return \texttt{NULL}.
		\item Otherwise, assign \texttt{Nnode} (number of nodes) to the output array and return it.
	\end{itemize}
	
	\item Fetch vectors from the dataset.  
	Set an element to masked if the $T$ value is within the threshold and either
	variable thresholding is false or threshold outlining is true.
	This condition is only possible when \texttt{Opt->ThreshRange[0] > 0}.
	
	\item Set up \texttt{nodedef} so it can be used with \texttt{Sover->V} for clusterizing.
	Since \texttt{Sover->V} will be modified in subsequent calls, this must be done now.
	
	\item \texttt{nd = SUMA\_GetNodeDef(dset)}
	\begin{itemize}
		\item \texttt{((!dset || !dset->inel || !dset->inel->vec) ? NULL : (int*)(dset->inel->vec[0]))}
		\item That is, get the vector of 3D color vectors at the first node of the dataset if it exists;
		otherwise return \texttt{NULL}.
	\end{itemize}
	
	\item Iterate over the filled vectors:
	\begin{itemize}
		\item If \texttt{nd} exists, copy \texttt{nd} into \texttt{Sover->NodeDef}.
		\item Otherwise, fill \texttt{Sover->NodeDef} with ones.
	\end{itemize}
	
	\item \texttt{Sover->FullList = NOPE;}
	
	\item Colorize:
	\begin{itemize}
		\item \texttt{SUMA\_ScaleToMap}
		\begin{itemize}
			\item Ensure there is an overlay, that it has a name, and that a colormap can be built.
			\item \texttt{SUMAg\_CF->scm = SUMA\_Build\_Color\_maps();}
			\begin{itemize}
				\item \texttt{SUMA\_Get\_AFNI\_Default\_Color\_Maps}
				\begin{enumerate}
					\item Initialize \texttt{N\_maps} and \texttt{N\_cols} to $-1$.
					Set \texttt{pthr[i] = 0.0} and \texttt{pov[i] = 0}.
					\item \texttt{Cv = SUMA\_Add\_Color("none", -1.0, -1.0, -1.0, 1.0, Cv, \&N\_cols);}
					\begin{enumerate}
						\item $(r,g,b)=(-1.0,-1.0,-1.0)$ denotes ``no color''.
						\item Otherwise, return an error if $(r,g,b)$ is outside $[0,1]$.
						\item Ensure the color name is not too long; otherwise return an error.
						\item If the color already exists, replace it with the new color.
						\item Add the new colormap.
					\end{enumerate}
				\end{enumerate}
			\end{itemize}
			
			\item \texttt{icmap = SUMA\_Find\_ColorMap}
			\item \texttt{ColMap = SUMAg\_CF->scm->CMv[icmap];}
			
			\item Create a scaled color vector:
			\begin{itemize}
				\item If show mode is \texttt{Con} or \texttt{CaC}:
				\begin{enumerate}
					\item If \texttt{SUMA\_NeedsLinearizing(ColMap)}:\\
					\hspace*{0.05in} $\ominus$  If nwarn:\\
						\hspace*{0.3in} $\oplus$ Display notice:
							\begin{quote}
								``Cannot do contouring with colormaps that have panes of unequal sizes.''
							\end{quote}
							\hspace*{0.4in} (Shown once per session.)\\
							\hspace*{0.3in} $\oplus$  Increment \texttt{nwarn}.\\
							\hspace*{0.3in} $\oplus$  Set \texttt{Opt->ColsContMode = 0}.\\
					\item Else, set \texttt{Opt->ColsContMode = 1}.
				\end{enumerate}
				\item Else, set \texttt{Opt->ColsContMode = 0}.
				\item \texttt{SUMA\_Create\_ColorScaledVect}
				\begin{enumerate}
					\item Allocate color scaled vector, $s$
					\item Allocate $S->cV$ and $S->masked$
					\item S->BiasCoordVec = NULL;
					\item S->N\_VCont = 0;
					\item if (!S->cV || !S->isMasked)
					\hspace{0.05in} $\ominus$  Display notice:
					\begin{quote}
						Failed to allocate for S->cV or S->isMasked.
					\end{quote}
					\hspace{0.05in} $\ominus$  Return error
					\item S->N\_Node = N\_Node;
					\item return s
				\end{enumerate}
				\item Fetch vectors from dset
				\begin{enumerate}
					\item Thresholding if (Opt->tind >= 0 \&\& Opt->UseThr)\\
						\hspace*{0.05in} $\ominus$ Fetch Threshold column SUMA\_SetOverlay\_Vecs\\
							\hspace*{0.25in} $\oplus$ if (!task) task = ``update''; /* Vanilla, recreate if necessary */\\
							\hspace*{0.25in} $\oplus$ if (!Sover) return error\\
							\hspace*{0.25in} $\oplus$ if (!Sover->dset\_link) return success\\
							\hspace*{0.25in} $\oplus$ if (Sover->dset\_link->dnel \&\&
							(attr=NI\_get\_attribute(Sover->dset\_link->dnel, "ResetOverlay\_Vecs")))\\
								\hspace*{0.35in} $\dagger$ if (!strcmp(attr,"yes"))\\
									\hspace*{0.45in} $\ddagger$ NI\_set\_attribute(Sover->dset\_link->dnel,"ResetOverlay\_Vecs", "nope");\\
									\hspace*{0.45in} $\ddagger$ SUMA\_DSET\_ClearOverlay\_Vecs(Sover->dset\_link)\\
										\hspace*{0.6in} $\cap$ if (!dset) return error\\
										\hspace*{0.6in} $\cap$ for (i=0; i<SUMAg\_N\_DOv; ++i) \\
										\hspace*{0.6in} $\cap$ ado = iDO\_ADO(i);\\
										\hspace*{0.6in} $\cap$ if ((over = SUMA\_ADO\_Overlays(ado, \& N\_over)))\\
											\hspace*{0.75in} $\cup$  for (k=0; k<N\_over; ++k)\\
												\hspace*{0.9in} $\bigtriangleup$  if (over[k]->dset\_link == dset)\\
													\hspace*{1.0in} $\bigtriangledown$  SUMA\_SetOverlay\_Vecs(over[k],'A', -1, "clear", -1)\\
										\hspace*{0.6in} $\cap$ return success\\
						\hspace*{0.05in} $\ominus$ setting SV->isMasked[i] means the node overlay is not shown (if Alpha, nothing gets masked out here\\
						\hspace*{0.05in} $\ominus$ Fetching Intensity column\\
						\hspace*{0.05in} $\ominus$ setup nodedef so that it can be used along with Sover->V for clusterinzing. Sover->V will get modified in subsequent calls so got to do it now\\
						\hspace*{0.05in} $\ominus$ Do we need clusterizing?  if (Opt->Clusterize)\\
							\hspace*{0.25in} $\oplus$ if (Opt->RecomputeClust) (Clusterizing requested)\\
								\hspace*{0.35in} $\dagger$ if (Sover->ClustList)  /* Clear old cluster list to make way for new one*/\\
								\hspace*{0.35in} $\dagger$ if (!(SO = SUMA\_SO\_of\_ColPlane(Sover)))\\
									\hspace*{0.45in} $\ddagger$	No clustering\\
								\hspace*{0.35in} $\dagger$ else\\
									\hspace*{0.45in} $\ddagger$	Opt->ClustOpt = SUMA\_create\_SurfClust\_Opt("InteractiveClust")\\
										\hspace*{0.6in} $\cap$ Allocate output Opt\\
										\hspace*{0.6in} $\cap$ Opt->out\_prefix = NULL;\\
										\hspace*{0.6in} $\cap$ Opt->oform = SUMA\_ASCII\_NIML;\\
										\hspace*{0.6in} $\cap$ Opt->DistLim = -1.5;\\
										\hspace*{0.6in} $\cap$ Opt->AreaLim = -1.0;\\
										\hspace*{0.6in} $\cap$ Opt->NodeLim = -1;\\
										\hspace*{0.6in} $\cap$ Opt->in\_name = NULL;\\
										\hspace*{0.6in} $\cap$ Opt->nodecol = -1;\\
										\hspace*{0.6in} $\cap$ Opt->labelcol = -1;\\
										\hspace*{0.6in} $\cap$ Opt->OutROI = NOPE;\\
										\hspace*{0.6in} $\cap$ Opt->OutClustDset = NOPE;\\
										\hspace*{0.6in} $\cap$ Opt->FullROIList = NOPE;\\
										\hspace*{0.6in} $\cap$ Opt->WriteFile = NOPE;\\
										\hspace*{0.6in} $\cap$ Opt->DoThreshold = SUMA\_NO\_THRESH;\\
										\hspace*{0.6in} $\cap$ Opt->ThreshR[0] = Opt->ThreshR[1] = 0.0;\\
										\hspace*{0.6in} $\cap$ Opt->tind = 0;\\
										\hspace*{0.6in} $\cap$ Opt->prepend\_node\_index = NOPE;\\
										\hspace*{0.6in} $\cap$ Opt->update = 0;\\
										\hspace*{0.6in} $\cap$ Opt->SortMode = SUMA\_SORT\_CLUST\_NOT\_SET;\\
										\hspace*{0.6in} $\cap$ Opt->DoCentrality = 1;\\
										\hspace*{0.6in} $\cap$ if (!init\_for || !strcmp(init\_for, "SurfClust"))\\
											\hspace*{0.75in} $\cup$ No more to do\\
										\hspace*{0.6in} $\cap$ else if (!strcmp(init\_for, "InteractiveClust"))\\
											\hspace*{0.75in} $\cup$ Opt->update = -(30000);\\
											\hspace*{0.75in} $\cup$ Opt->AreaLim = -1.0;\\
											\hspace*{0.75in} $\cup$ Opt->NodeLim = -1;\\
											\hspace*{0.75in} $\cup$ Opt->DoCentrality = 0; \\
											\hspace*{0.75in} $\cup$ Opt->DistLim = -1;\\
											\hspace*{0.75in} $\cup$ Opt->SortMode = SUMA\_SORT\_CLUST\_BY\_AREA;\\
										\hspace*{0.6in} $\cap$ else\\
											\hspace*{0.75in} $\cup$ Don't know how to init for this. Returning with defaults for SurfClust program\\
										\hspace*{0.6in} $\cap$ return Opt
										
								
				\end{enumerate}					
			\end{itemize}
		\end{itemize}
	\end{itemize}
\end{itemize}

\end{document}

