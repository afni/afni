\documentclass[twoside,onecolumn]{article}

\usepackage{blindtext} % Package to generate dummy text throughout this template 

\usepackage[sc]{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics

\usepackage[english]{babel} % Language hyphenation and typographical rules

\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry} % Document margins
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions under/above floats in tables or figures
\usepackage{booktabs} % Horizontal rules in tables

\usepackage{lettrine} % The lettrine is the first enlarged letter at the beginning of the text

\usepackage{graphicx}

\usepackage{enumitem} % Customized lists
\setlist[itemize]{noitemsep} % Make itemize lists more compact

\usepackage{abstract} % Allows abstract customization
\renewcommand{\abstractnamefont}{\normalfont\bfseries} % Set the "Abstract" text to bold
\renewcommand{\abstracttextfont}{\normalfont\small\itshape} % Set the abstract itself to small italic text

\usepackage{titlesec} % Allows customization of titles
\renewcommand\thesection{\Roman{section}} % Roman numerals for the sections
\renewcommand\thesubsection{\roman{subsection}} % roman numerals for subsections
\titleformat{\section}[block]{\large\scshape\centering}{\thesection.}{1em}{} % Change the look of the section titles
\titleformat{\subsection}[block]{\large}{\thesubsection.}{1em}{} % Change the look of the section titles

\usepackage{fancyhdr} % Headers and footers
\pagestyle{fancy} % All pages have headers and footers
\fancyhead{} % Blank out the default header
\fancyfoot{} % Blank out the default footer
\fancyhead[C]{Running title $\bullet$ May 2016 $\bullet$ Vol. XXI, No. 1} % Custom header text
\fancyfoot[RO,LE]{\thepage} % Custom footer text

\usepackage{enumitem}
%\usepackage{paralist}
%\setlistdepth{20}
%\renewlist{compactitem}{itemize}{20}
%\setlist[compactitem]{label=$\cdot$}
%
%% Redefine bullet symbols for nested lists
%\renewcommand{\labelitemi}{$\bullet$}       % level 1
%\renewcommand{\labelitemii}{$\circ$}        % level 2
%\renewcommand{\labelitemiii}{$\triangleright$} % level 3
%\renewcommand{\labelitemiv}{$\diamond$}     % level 4

\usepackage{enumitem}

% Define bullet styles per level (add more if needed)
\setlist[itemize,1]{label=$\bullet$}
\setlist[itemize,2]{label=$\circ$}
\setlist[itemize,3]{label=$\triangleright$}
\setlist[itemize,4]{label=$\diamond$}
\setlist[itemize,5]{label=$\star$}
\setlist[itemize,6]{label=$\cdot$}  % add more levels as needed
\setlist[itemize,7]{label=$-$}
\setlist[itemize,8]{label=$\ast$}
\setlist[itemize,9]{label=$rhd$}
\setlist[itemize,10]{label=$lhd$}
\setlist[itemize,11]{label=$\bigtriangleup$}
\setlist[itemize,12]{label=$bigtriangledown$}
\setlist[itemize,13]{label=$triangleleft$}
\setlist[itemize,14]{label=$triangleright$}
\setlist[itemize,15]{label=$unlhd$}
\setlist[itemize,16]{label=$unrhd$}
\setlist[itemize,17]{label=$oplus$}
\setlist[itemize,18]{label=$ominus$}
\setlist[itemize,19]{label=$otimes$}
\setlist[itemize,20]{label=$oslash$}
\setlist[itemize,21]{label=$obigcirc$}
\setlist[itemize,22]{label=$dagger$}
\setlist[itemize,23]{label=$ddagger$}
\setlist[itemize,24]{label=$cap$}
\setlist[itemize,25]{label=$cup$}


\usepackage{amsmath}

\begin{document}

\section*{SUMA\_MakeThresholdOutlines}

\begin{itemize}
	\item \texttt{ado = {\bf SUMA\_Overlay\_OwnerADO}(Sover);}
	\item \texttt{SO = (SUMA\_SurfaceObject *)ado;}
	\item Check that required pointers are not \texttt{NULL}
	
	\item \texttt{{\bf SUMA\_Find\_ColorMap}}
	\begin{itemize}
		\item Ensure that color maps exist; if not, exit.
		\item Cycle through maps to find the required map.
		\item If found, return the map; otherwise return failure.
	\end{itemize}
	
	\item If colormap not found, return with an error message.
	\item Create a scaled color vector.
	
	\item If show mode is \texttt{Con} or \texttt{CaC}:
	\begin{itemize}
		\item \texttt{return = {\bf SUMA\_NeedsLinearizing}(ColMap)}
		\begin{itemize}
			\item If there is no $N_{\text{col}} \times 1$ vector containing the fraction of scale assigned to each color
			(values shown on the right of the colorbar in AFNI), return 0.
			\item If the number of colors in the colormap $\times$ the number of columns in $M$
			(where $M$ is an $N_{\text{col}} \times 3$ matrix of RGB values in $[0,1]$), return 0.
			\item If there is a hot spot in the color vector, return 1; otherwise return 0.
		\end{itemize}
	\end{itemize}
	
	\item Else, set \texttt{ColsContMode = 0}.
	
	\item Create color scale vector:
	\begin{itemize}
		\item Allocate memory for the color scale vector.
		\item Allocate memory for its \texttt{cv} and \texttt{isMasked} components for the number of nodes.
		The \texttt{BiasCoordVec} component is set to \texttt{NULL} until it is determined whether it is needed.
		\item If \texttt{ColsContMode}, allocate \texttt{vCont} for the number of nodes.
		\item If allocation of \texttt{cv} or \texttt{isMasked} fails, return \texttt{NULL}.
		\item Otherwise, assign \texttt{Nnode} (number of nodes) to the output array and return it.
	\end{itemize}
	
	\item Fetch vectors from the dataset.  
	\item Set element to masked if T value within $\pm$	the threshold AND either variable thresholding false or threshold outlining true.  The condition is only possible when	Opt->ThreshRange[0] > 0*
	\item Setup nodedef so that it can be used along with Sover->V for clusterinzing. Sover->V will get modified in subsequent calls so got to do it now
	\item nd = SUMA\_GetNodeDef(Sover->dset\_link);
	\item If node indices (nd) are available, assign them to each surface node.  Otherwise, assign, to each surface node, its order in the dset\_link array.
	\item Sover->FullList = NOPE;	
	\item Colorize:
	\begin{itemize}
		\item \texttt{{\bf SUMA\_ScaleToMap}}
		\begin{itemize}
			\item If colormap sign negative, proceed, in SUMA options were given to the user to make the range symmetric about 0. They can shoot themselves in the foot if they want to
			\item Find the values to be masked out
			\item Refuse to deal with top\_frac here, SUMA does not allow for colormaps to have a top != 1 First pass at implementing top != 1 does exist below but is now turned off. I don't feel like testing it..
			\item go through and clip values in V to those specified in the range
			\item Ensure there is an overlay, that it has a name, and that a colormap can be built.
			\item \texttt{{\bf SUMAg\_CF->scm = SUMA\_Build\_Color\_maps}();}
			\begin{itemize}
				\item \texttt{{\bf SUMA\_Get\_AFNI\_Default\_Color\_Maps}}
				\begin{enumerate}
					\item Initialize \texttt{N\_maps} and \texttt{N\_cols} to $-1$.
					Set \texttt{pthr[i] = 0.0} and \texttt{pov[i] = 0}.
					\item \texttt{Cv = {\bf SUMA\_Add\_Color}("none", -1.0, -1.0, -1.0, 1.0, Cv, \&N\_cols);}
					\begin{enumerate}
						\item $(r,g,b)=(-1.0,-1.0,-1.0)$ denotes ``no color''.
						\item Otherwise, return an error if $(r,g,b)$ is outside $[0,1]$.
						\item Ensure the color name is not too long; otherwise return an error.
						\item If the color already exists, replace it with the new color.
						\item Add the new colormap.
						\item If apply clip ... Applying Clip (This one's not used in interactive mode anymore  because clipping is handled in the colormapping part)
							\hspace*{0.05in} $\ominus$  if (top\_frac > 0.0f) )Not fully tested)\\
								\hspace*{0.25in} $\oplus$ Multiply threshold range by top\_frac\\
							\hspace*{0.05in} $\ominus$  For each node\\
								\hspace*{0.25in} $\oplus$ if masked, clip to Opt->IntRange.\\
							\hspace*{0.05in} $\ominus$ Vmin = Opt->IntRange[0];\\
							\hspace*{0.05in} $\ominus$ Vmax = Opt->IntRange[1];\\
							\hspace*{0.05in} $\ominus$ if top\_frac positive, divide threshold range by top\_frac\\
							\hspace*{0.05in} $\ominus$ Otherwise set Vmin and Vmax to top\_frac\\
							\hspace*{0.05in} $\ominus$ Add any coord bias\\
							\hspace*{0.05in} $\ominus$ if ({\bf SUMA\_NeedsLinearizing}(ColMap))\\
								\hspace*{0.25in} $\oplus$ if (Opt->interpmode == SUMA\_NO\_INTERP || Opt->interpmode == SUMA\_INTERP)\\
									\hspace*{0.35in} $\dagger$ linearize color map
								\hspace*{0.25in} $\oplus$ else if (Opt->interpmode != SUMA\_DIRECT)\\
									\hspace*{0.35in} $\dagger$ Do nothing to the colormap, direct mapping mode in gear\\
							\hspace*{0.05in} $\ominus$  else NO Linearizing of colormap deemed necessary\\
						\item if brightness factor is given, apply it to color map and mask color
							\hspace*{0.05in} $\ominus$ if (Opt->BrightFact <= 0 || Opt->BrightFact > 2) Opt->BrightFact = 1.0;\\
							\hspace*{0.05in} $\ominus$ if (Opt->BrightFact != 1.0)\\
								\hspace*{0.25in} $\oplus$ Modulate brightness of map\\
									\hspace*{0.35in} $\dagger$ Clip ColMap->M to rbg = (1.0, 1.0, 1.0)\\
									\hspace*{0.35in} $\dagger$ Clip Opt->MaskColor to rbg = (1.0, 1.0, 1.0)\\
						\item Check whether Opt->interpmode is correctly specified
						\item if (Opt->interpmode == SUMA\_NO\_INTERP || Opt->interpmode == SUMA\_INTERP)
							\hspace*{0.05in} $\ominus$ go through values and interpolate onto index of colormap \\
							\hspace*{0.05in} $\ominus$ if (Opt->interpmode == SUMA\_NO\_INTERP) (no interpolation between colours)\\
								\hspace*{0.25in} $\oplus$ For each node\\
									\hspace*{0.35in} $\dagger$ if Min--Max are within the boundaries of the data's (V[i]) min to max\\
										\hspace*{0.45in} $\ddagger$ Vscl = ColMap->N\_M[0];\\
							\hspace*{0.05in} $\ominus$ else (interpolation mode)\\ 
								\hspace*{0.25in} $\oplus$ copy masked values from Opt->MaskColor to SV->cV\\
								\hspace*{0.25in} $\oplus$ Unmasked values blended with neighbors\\
						\item else (direct color mapping)
							\hspace*{0.05in} $\ominus$ ColMap->M or Opt->MaskColor (depending on masking) RGB values copied into SV->cV\\ 
						\item change range for coord bias						
								
					\end{enumerate}
					\item get the rgb, floats of each color defined DEFAULT\_NCOLOVR
					\item create the afni color maps with more than 10 panes (excerpts from afni.c
					\begin{enumerate}
						\item start with positive panes
						\item initialize signed pbar panes
						\item create AFNI's colormaps
						\item perhaps someday include the continuous color maps from AFNI too
						\item load whatever's lurking in the .afnirc files passing NULL for dc (the last parameter) because I am not using the continuous color maps yet
					\end{enumerate}
				\end{enumerate}
				\item add SUMA's colormaps
				\item load cmaps from user's directory
				\item load cmaps from current directory
			\end{itemize}
			
			\item \texttt{icmap = {\bf SUMA\_Find\_ColorMap}}
			\item \texttt{ColMap = SUMAg\_CF->scm->CMv[icmap];}
			
			\item Create a scaled color vector:
			\begin{itemize}
				\item If show mode is \texttt{Con} or \texttt{CaC}:
				\begin{enumerate}
					\item If \texttt{SUMA\_NeedsLinearizing(ColMap)}:\\
					\hspace*{0.05in} $\ominus$  If nwarn:\\
						\hspace*{0.3in} $\oplus$ Display notice:
							\begin{quote}
								``Cannot do contouring with colormaps that have panes of unequal sizes.''
							\end{quote}
							\hspace*{0.4in} (Shown once per session.)\\
							\hspace*{0.3in} $\oplus$  Increment \texttt{nwarn}.\\
							\hspace*{0.3in} $\oplus$  Set \texttt{Opt->ColsContMode = 0}.\\
					\item Else, set \texttt{Opt->ColsContMode = 1}.
				\end{enumerate}
				\item Else, set \texttt{Opt->ColsContMode = 0}.
				\item \texttt{{\bf SUMA\_Create\_ColorScaledVect}}
				\begin{enumerate}
					\item Allocate color scaled vector, $s$
					\item Allocate $S->cV$ and $S->masked$
					\item S->BiasCoordVec = NULL;
					\item S->N\_VCont = 0;
					\item if (!S->cV || !S->isMasked)
					\hspace{0.05in} $\ominus$  Display notice:
					\begin{quote}
						Failed to allocate for S->cV or S->isMasked.
					\end{quote}
					\hspace{0.05in} $\ominus$  Return error
					\item S->N\_Node = N\_Node;
					\item return s
				\end{enumerate}
				\item Fetch vectors from dset
				
				\begin{enumerate}
					\item Thresholding if (Opt->tind >= 0 \&\& Opt->UseThr)\\
						\hspace*{0.05in} $\ominus$ Fetch Threshold column {\em SUMA\_SetOverlay\_Vecs}\\
							\hspace*{0.25in} $\oplus$ if (!task) task = ``update''; /* Vanilla, recreate if necessary */\\
							\hspace*{0.25in} $\oplus$ if (!Sover) return error\\
							\hspace*{0.25in} $\oplus$ if (!Sover->dset\_link) return success\\
							\hspace*{0.25in} $\oplus$ if (Sover->dset\_link->dnel \&\&\\
							\hspace*{0.35in}(attr={\bf NI\_get\_attribute}(Sover->dset\_link->dnel,\\
							\hspace*{0.35in} "ResetOverlay\_Vecs")))\\
								\hspace*{0.35in} $\dagger$ if (!strcmp(attr,"yes"))\\
									\hspace*{0.45in} $\ddagger$ NI\_set\_attribute(Sover->dset\_link->dnel,"ResetOverlay\_Vecs", "nope");\\
									\hspace*{0.45in} $\ddagger$ {\bf SUMA\_DSET\_ClearOverlay\_Vecs}(Sover->dset\_link)\\
										\hspace*{0.6in} $\cap$ if (!dset) return error\\
										\hspace*{0.6in} $\cap$ for (i=0; i<SUMAg\_N\_DOv; ++i) \\
										\hspace*{0.6in} $\cap$ ado = iDO\_ADO(i);\\
										\hspace*{0.6in} $\cap$ if ((over = {\bf SUMA\_ADO\_Overlays}(ado, \& N\_over)))\\
											\hspace*{0.75in} $\cup$  for (k=0; k<N\_over; ++k)\\
												\hspace*{0.9in} $\bigtriangleup$  if (over[k]->dset\_link == dset)\\
													\hspace*{1.0in} $\bigtriangledown$  {\bf SUMA\_SetOverlay\_Vecs}(over[k],'A', -1, "clear", -1)\\
										\hspace*{0.6in} $\cap$ return success\\
						\hspace*{0.05in} $\ominus$ setting SV->isMasked[i] means the node overlay is not shown (if Alpha, nothing gets masked out here\\
						\hspace*{0.05in} $\ominus$ Fetching Intensity column\\
						\hspace*{0.05in} $\ominus$ setup nodedef so that it can be used along with Sover->V for clusterinzing. Sover->V will get modified in subsequent calls so got to do it now\\
						\hspace*{0.05in} $\ominus$ Do we need clusterizing?  if (Opt->Clusterize)\\
							\hspace*{0.25in} $\oplus$ if (Opt->RecomputeClust) (Clusterizing requested)\\
								\hspace*{0.35in} $\dagger$ if (Sover->ClustList) Clear old cluster list to make way for new one\\
								\hspace*{0.35in} $\dagger$ if (!(SO = SUMA\_SO\_of\_ColPlane(Sover)))\\
									\hspace*{0.45in} $\ddagger$	No clustering\\
								\hspace*{0.35in} $\dagger$ else\\
									\hspace*{0.45in} $\ddagger$	Opt->ClustOpt = {\bf SUMA\_create\_SurfClust\_Opt}("InteractiveClust")\\
										\hspace*{0.6in} $\cap$ Allocate output Opt\\
										\hspace*{0.6in} $\cap$ Opt->out\_prefix = NULL;\\
										\hspace*{0.6in} $\cap$ Opt->oform = SUMA\_ASCII\_NIML;\\
										\hspace*{0.6in} $\cap$ Opt->DistLim = -1.5;\\
										\hspace*{0.6in} $\cap$ Opt->AreaLim = -1.0;\\
										\hspace*{0.6in} $\cap$ Opt->NodeLim = -1;\\
										\hspace*{0.6in} $\cap$ Opt->in\_name = NULL;\\
										\hspace*{0.6in} $\cap$ Opt->nodecol = -1;\\
										\hspace*{0.6in} $\cap$ Opt->labelcol = -1;\\
										\hspace*{0.6in} $\cap$ Opt->OutROI = NOPE;\\
										\hspace*{0.6in} $\cap$ Opt->OutClustDset = NOPE;\\
										\hspace*{0.6in} $\cap$ Opt->FullROIList = NOPE;\\
										\hspace*{0.6in} $\cap$ Opt->WriteFile = NOPE;\\
										\hspace*{0.6in} $\cap$ Opt->DoThreshold = SUMA\_NO\_THRESH;\\
										\hspace*{0.6in} $\cap$ Opt->ThreshR[0] = Opt->ThreshR[1] = 0.0;\\
										\hspace*{0.6in} $\cap$ Opt->tind = 0;\\
										\hspace*{0.6in} $\cap$ Opt->prepend\_node\_index = NOPE;\\
										\hspace*{0.6in} $\cap$ Opt->update = 0;\\
										\hspace*{0.6in} $\cap$ Opt->SortMode = SUMA\_SORT\_CLUST\_NOT\_SET;\\
										\hspace*{0.6in} $\cap$ Opt->DoCentrality = 1;\\
										\hspace*{0.6in} $\cap$ if (!init\_for || !strcmp(init\_for, "SurfClust"))\\
											\hspace*{0.75in} $\cup$ No more to do\\
										\hspace*{0.6in} $\cap$ else if (!strcmp(init\_for, "InteractiveClust"))\\
											\hspace*{0.75in} $\cup$ Opt->update = -(30000);\\
											\hspace*{0.75in} $\cup$ Opt->AreaLim = -1.0;\\
											\hspace*{0.75in} $\cup$ Opt->NodeLim = -1;\\
											\hspace*{0.75in} $\cup$ Opt->DoCentrality = 0; \\
											\hspace*{0.75in} $\cup$ Opt->DistLim = -1;\\
											\hspace*{0.75in} $\cup$ Opt->SortMode = SUMA\_SORT\_CLUST\_BY\_AREA;\\
										\hspace*{0.6in} $\cap$ else\\
											\hspace*{0.75in} $\cup$ Don't know how to init for this. Returning with defaults for\\
											 \hspace*{0.85in} SurfClust program\\
										\hspace*{0.6in} $\cap$ return Opt\\
									\hspace*{0.45in} $\ddagger$	Sover->ClustList = {\bf SUMA\_FindClusters} \\
										\hspace*{0.6in} $\cap$ Ensure valid surface object, vertex count and node count\\
										\hspace*{0.6in} $\cap$ If no node areas\\
											\hspace*{0.75in} $\cup$ if (!SO->NodeAreas) SO->NodeAreas = {\bf SUMA\_CalculateNodeAreas}\\
												\hspace*{0.9in} $\bigtriangleup$  If no valid surface object, return NULL\\
												\hspace*{0.9in} $\bigtriangleup$ if (!SO->PolyArea || !SO->MF)\\
													\hspace*{1.0in} $\bigtriangledown$ {\bf SUMA\_SurfaceMetrics\_eng}\\
														\hspace*{1.2in} $\triangleleft$ DoMF = YUP;\\
														\hspace*{1.2in} $\triangleleft$ if (SO->MF != NULL) return error while complaining\\ 
															\hspace*{1.3in} about SO->MF being precomputed\\
														\hspace*{1.2in} $\triangleleft$ if (SOinh)\\
															\hspace*{1.4in} $\triangleright$ if (idcode mismatch)\\
																\hspace*{1.6in} $\cdot$ Cannot inherit MemberFaceSet.  Independent\\ 
																	\hspace*{1.8in} lists will be created.\\
																\hspace*{1.6in} $\cdot$  SOinh = NULL;\\
															\hspace*{1.4in} $\triangleright$ else if (Node number mismatch)\\
																\hspace*{1.6in} $\cdot$ Cannot inherit MemberFaceSet.  Independent\\ 
																	\hspace*{1.8in} lists will be created.\\
																\hspace*{1.6in} $\cdot$  SOinh = NULL;\\
														\hspace*{1.2in} $\triangleleft$ if (!SOinh)\\				
															\hspace*{1.4in} $\triangleright$ determine the MemberFaceSets {\bf SUMA\_MemberFaceSets}\\
																\hspace*{1.6in} $\cdot$ Allocate return variables\\
																\hspace*{1.6in} $\cdot$ loop through all facesets and tag nodes that make\\
																\hspace*{1.8in} up FaceSets\\
																\hspace*{1.6in} $\cdot$ allocate just enough for returning variables\\
																\hspace*{1.6in} $\cdot$ loop through all nodes, cp results into\\
																\hspace*{1.8in} RetStrct->NodeMemberOfFaceSet and seal\\
																 \hspace*{1.8in} with -1\\
														\hspace*{1.2in} $\triangleleft$ else\\
															\hspace*{1.4in} $\triangleright$ inherit the MemberFaceSets\\
												\hspace*{0.9in} $\bigtriangleup$ Allocate for NodeAreas\\
												\hspace*{0.9in} $\bigtriangleup$ for (i=0; i<SO->N\_Node; ++i)\\
													\hspace*{1.0in} $\bigtriangledown$ NodeAreas[i] = 0.0;\\
													\hspace*{1.0in} $\bigtriangledown$ if (!mask || mask[i])\\
														\hspace*{1.2in} $\triangleleft$ flist = SO->MF->NodeMemberOfFaceSet[i];\\
														\hspace*{1.2in} $\triangleleft$ for (c = 0; c < SO->MF->N\_Memb[i]; c++)\\
															\hspace*{1.4in} $\triangleright$ NodeAreas[i] += SO->PolyArea[flist[c]];\\
														\hspace*{1.2in} $\triangleleft$ NodeAreas[i] /= 3.0;\\
												\hspace*{0.9in} $\bigtriangleup$  return NodeAreas\\
											\hspace*{0.75in} $\cup$ if (dothisnode == -1)\\			
												\hspace*{0.9in} $\bigtriangleup$ initialize the list\\
											\hspace*{0.75in} $\cup$ while there is not a vertex for each node ...\\
												\hspace*{0.9in} $\bigtriangleup$ Identify unassigned nodes\\
												\hspace*{0.9in} $\bigtriangleup$ {\bf SUMA\_Build\_Cluster\_From\_Node\_NoRec}\\
													\hspace*{1.0in} $\bigtriangledown$ if (Opt->update < 0)\\
														\hspace*{1.2in} $\triangleleft$ N\_Orig = *N\_TobeAssigned \\
														\hspace*{1.2in} $\triangleleft$ Opt->update = -Opt->update\\
													\hspace*{1.0in} $\bigtriangledown$ OffS = SUMA\_Initialize\_getoffsets (SO->N\_Node);\\
													\hspace*{1.0in} $\bigtriangledown$ allocate Clust\\
													\hspace*{1.0in} $\bigtriangledown$ Clust->N\_Node = 0;\\
													\hspace*{1.0in} $\bigtriangledown$ Clust->totalarea = 0.0;\\
													\hspace*{1.0in} $\bigtriangledown$ Clust->totalvalue = 0.0;\\
													\hspace*{1.0in} $\bigtriangledown$ Clust->totalabsvalue = 0.0;\\  
													\hspace*{1.0in} $\bigtriangledown$ Clust->minvalue = ToBeAssigned[dothisnode];\\
													\hspace*{1.0in} $\bigtriangledown$ Clust->minnode = dothisnode;\\
													\hspace*{1.0in} $\bigtriangledown$ Clust->maxvalue = ToBeAssigned[dothisnode];\\
													\hspace*{1.0in} $\bigtriangledown$ Clust->maxnode = dothisnode;\\ 
													\hspace*{1.0in} $\bigtriangledown$ Clust->minabsvalue = SUMA\_ABS(Clust->minvalue);\\ 
													\hspace*{1.0in} $\bigtriangledown$ Clust->minabsnode = Clust->minnode;\\
													\hspace*{1.0in} $\bigtriangledown$ Clust->maxabsvalue = SUMA\_ABS(Clust->maxvalue); \\
													\hspace*{1.0in} $\bigtriangledown$ Clust->maxabsnode = Clust->maxnode;\\
													\hspace*{1.0in} $\bigtriangledown$ Clust->varvalue = 0.0;\\
													\hspace*{1.0in} $\bigtriangledown$ Clust->centralnode = 0; \\
													\hspace*{1.0in} $\bigtriangledown$ Clust->weightedcentralnode = 0;\\
													\hspace*{1.0in} $\bigtriangledown$ allocate Clust->NodeList\\
													\hspace*{1.0in} $\bigtriangledown$ allocate Clust->ValueList\\
													\hspace*{1.0in} $\bigtriangledown$ memset(Clust->com, 0, 3*sizeof(float));\\
													\hspace*{1.0in} $\bigtriangledown$ memset(Clust->cen, 0, 3*sizeof(float));\\
													\hspace*{1.0in} $\bigtriangledown$ Ensure Clust->NodeList, Clust->ValueList and OffS\\
													 \hspace*{1.4in} allocated\\
													\hspace*{1.0in} $\bigtriangledown$ Ensure visited and candlist allocated\\
													\hspace*{1.0in} $\bigtriangledown$ {\bf SUMA\_ADD\_NODE\_TO\_CLUST}\\
														\hspace*{1.2in} $\triangleleft$ Clust->NodeList[Clust->N\_Node] = dothisnode;\\
														\hspace*{1.2in} $\triangleleft$ Clust->totalarea += NodeArea[dothisnode];\\
														\hspace*{1.2in} $\triangleleft$ Clust->totalvalue += ToBeAssigned[dothisnode];\\
														\hspace*{1.2in} $\triangleleft$ Clust->totalabsvalue += (float)fabs((float)ToBeAssigned[dothisnode]);\\
														\hspace*{1.2in} $\triangleleft$ if (ToBeAssigned[dothisnode] < Clust->minvalue)\\
															\hspace*{1.4in} $\triangleright$ Clust->minvalue = ToBeAssigned[dothisnode\\ 
															\hspace*{1.4in} $\triangleright$ ToBeAssigned[dothisnode]\\
															\hspace*{1.4in} Clust->minnode = dothisnode\\
														\hspace*{1.2in} $\triangleleft$ if (ToBeAssigned[dothisnode] > Clust->maxvalue)\\
															\hspace*{1.4in} $\triangleright$ Clust->maxvalue = ToBeAssigned[dothisnode]\\
															\hspace*{1.4in} $\triangleright$  Clust->maxnode = dothisnode; \\
														\hspace*{1.2in} $\triangleleft$ if (SUMA\_ABS(ToBeAssigned[dothisnode])\\
														\hspace*{1.6in} < Clust->minabsvalue)\\			  		
															\hspace*{1.4in} $\triangleright$ Clust->minabsvalue = SUMA\_ABS(ToBeAssigned[dothisnode]);\\
															\hspace*{1.4in} $\triangleright$  Clust->minabsnode = dothisnode;\\
														\hspace*{1.2in} $\triangleleft$ if (SUMA\_ABS(ToBeAssigned[dothisnode]) > \\
														\hspace*{1.6in} Clust->maxabsvalue)\\
															\hspace*{1.4in} $\triangleright$ Clust->maxabsvalue = SUMA\_ABS(ToBeAssigned[dothisnode]); \hspace*{1.4in} $\triangleright$ Clust->maxabsnode = dothisnode; \\
														\hspace*{1.2in} $\triangleleft$ Clust->ValueList[Clust->N\_Node] = ToBeAssigned[dothisnode];\\
														\hspace*{1.2in} $\triangleleft$ nnn = SO->NodeDim*dothisnode;\\
														\hspace*{1.2in} $\triangleleft$ for (kkk = 0; kkk<SO->NodeDim; ++kkk) \\
															\hspace*{1.4in} $\triangleright$ Clust->com[kkk] += ToBeAssigned[dothisnode] * \\
															 \hspace*{1.6in} SO->NodeList[nnn+kkk];\\
															\hspace*{1.4in} $\triangleright$ Clust->cen[kkk] += SO->NodeList[nnn+kkk];\\
														\hspace*{1.2in} $\triangleleft$ ++Clust->N\_Node;\\
													\hspace*{1.0in} $\bigtriangledown$ mark it as assigned, an reduce the number of nodes left\\
													 \hspace*{1.2in} to assign\\
													\hspace*{1.0in} $\bigtriangledown$ While nodes to be assigned and $\exists$ candidate list\\
														\hspace*{1.2in} $\triangleleft$ look in its vicinity\\
														\hspace*{1.2in} $\triangleleft$ remove node from candidate list\\	
														\hspace*{1.2in} $\triangleleft$ search to see if any are to be assigned\\
															\hspace*{1.4in} $\triangleright$ if (Opt->DistLim >= 0.0)\\
																\hspace*{1.6in} $\cdot$ For each layer ...\\
																	\hspace*{1.8in} $\longrightarrow$ starting at layer 1, layer 0 is the node itself\\
																		\hspace*{2.0in} $\rightarrow$ take that node into the cluster\\
																		\hspace*{2.0in} $\rightarrow$ mark it as assigned, an reduce the\\
																		\hspace*{2.2in}  number of nodes left to assign\\
																		\hspace*{2.0in} $\rightarrow$  mark it as a candidate if it has not been\\
																		\hspace*{2.2in}  visited as a candidate before\\
															\hspace*{1.4in} $\triangleright$ else (accept nodes connected by up to\\
															 \hspace*{1.8in} -((int)Opt->DistLim) edges)\\
																\hspace*{1.6in} $\cdot$ For each unassigned node ...\\
																	\hspace*{1.8in} $\longrightarrow$ take that node into the cluster\\
																	\hspace*{1.8in} $\longrightarrow$ mark it as assigned, an reduce the number\\
																	\hspace*{2.0in} of nodes left to assign\\
																	\hspace*{1.8in} $\longrightarrow$ mark it as a candidate if it has not been\\
																	\hspace*{2.0in} visited as a candidate before\\
															\hspace*{1.4in} $\triangleright$ {\bf SUMA\_Recycle\_getoffsets}\\
																\hspace*{1.6in} $\cdot$ For each layer, \\
																	\hspace*{1.8in} $\longrightarrow$ reset the layer index of used nodes\\
																	\hspace*{2.0in} in LayerVect\\
																	\hspace*{1.8in} $\longrightarrow$ reset number of nodes in each layer\\
												\hspace*{0.9in} $\bigtriangleup$ if ( (Opt->AreaLim > 0 \&\& Clust->totalarea < Opt->AreaLim)  ||\\ 
												\hspace*{1.2in} (Opt->NodeLim > 0 \&\& Clust->N\_Node < Opt->NodeLim) ||\\
												\hspace*{1.2in} (Opt->NodeLim < 0 \&\& Opt->AreaLim < 0 \&\& \\
												\hspace*{1.2in} Clust->N\_Node < -Opt->AreaLim) \\	
													\hspace*{1.0in} $\bigtriangledown$ Allow users to use a negative area in the interface to have the effect of limiting by number of nodes	\\
												\hspace*{0.9in} $\bigtriangleup$ else\\
													\hspace*{1.0in} $\bigtriangledown$ Find node mean\\
													\hspace*{1.0in} $\bigtriangledown$ Find node variance\\
													\hspace*{1.0in} $\bigtriangledown$ find the central node \\
									\hspace*{0.45in} $\ddagger$					
				\end{enumerate}					
			\end{itemize}
			\item if (Opt->ColsContMode) (Do we need to create contours)
			\begin{itemize}
				\item if ({\bf SUMA\_is\_Label\_dset}(Sover->dset\_link,NULL))
				\begin{enumerate}
					\item if (!dset)  return false
					\item if (SUMA\_isVolDataset(dset)) and {\bf SUMA\_GetAtlasLabelTable}(dset)
					\begin{enumerate}
						\item return {\bf SUMA\_FindDsetAttributeElement}(dset, "ATLAS\_LABEL\_TABLE")
							\hspace*{0.05in} $\ominus$ if (!dset || !dset->ngr) return NULL\\
							\hspace*{0.05in} return {\bf SUMA\_FindNgrAttributeElement}(dset->ngr, attname)\\
								\hspace*{0.25in} $\oplus$ if (!ngr || !attname) return NULL\\
								\hspace*{0.25in} $\oplus$ now read the elements in this group and return the element with\\
								\hspace*{0.30in} the given attribute name\\
								\hspace*{0.25in} $\oplus$ Return this element if found.  Otherwise, return NULL\\
					\end{enumerate}
					or {\bf SUMA\_GetValueLabelTable}(dset)) return true
						\hspace*{0.05in} $\ominus$ return SUMA\_FindDsetAttributeElement (dset, "VALUE\_LABEL\_DTABLE") return true
					\item Check on the dset\_type attribute.  This check is needed to tell the difference between NODE\_ROI datasets that are treated as regular datasets, and NODE\_LABEL which are rendered differently. Both types have a dset column that is of type SUMA\_NODE\_ILABEL
				\end{enumerate}
				\begin{enumerate}
					\item {\bf SUMA\_ContourateDsetOverlay}(Sover, NULL, SO)
					\begin{enumerate}
						\item Ensure cp and cp->dset\_link not NULL
						\item if (!SV) 
							\hspace*{0.05in} $\ominus$ if (SUMA\_is\_Label\_dset(cp->dset\_link,NULL) || \\
							\hspace*{0.15in} SUMA\_is\_Label\_dset\_col(cp->dset\_link, cp->OptScl->find))\\
								\hspace*{0.25in} $\oplus$ Remove existing contours if any\\
								\hspace*{0.25in} $\oplus$ Get node index column\\
								\hspace*{0.25in} $\oplus$ Get key\\
								\hspace*{0.25in} $\oplus$ cp->Contours = {\bf SUMA\_MultiColumnsToDrawnROI}SUMA\_MultiColumnsToDrawnROI(SDSET\_VECLEN(cp->dset\_link)\\
									\hspace*{0.35in} $\dagger$ 
					\end{enumerate}
				\end{enumerate}
			\end{itemize}
		\end{itemize}
	\end{itemize}
\end{itemize}

\end{document}

